# 第11章：大容量存储系统（Mass-Storage Systems）

## 目录
1. [大容量存储结构概述](#大容量存储结构概述)
2. [磁盘调度算法](#磁盘调度算法)
3. [NVM调度](#nvm调度)
4. [错误检测与纠正](#错误检测与纠正)
5. [存储设备管理](#存储设备管理)
6. [交换空间管理](#交换空间管理)
7. [存储连接方式](#存储连接方式)
8. [RAID结构](#raid结构)
9. [对象存储](#对象存储)
10. [性能计算](#性能计算)

---

## 大容量存储结构概述

### 1. 硬盘驱动器（HDD - Hard Disk Drives）

#### 基本结构
- **盘片（Platters）**：涂有磁性材料的圆形盘片
- **读写头（Read-Write Heads）**：在盘片上方移动，进行数据读写
- **主轴（Spindle）**：驱动盘片旋转
- **磁道（Tracks）**：盘片上的同心圆
- **扇区（Sectors）**：磁道上的最小存储单元
- **柱面（Cylinders）**：所有盘片上相同半径的磁道集合

#### 物理规格
- **盘片尺寸**：历史上从0.85英寸到14英寸
- **常见尺寸**：
  - 3.5英寸（桌面电脑）
  - 2.5英寸（笔记本电脑）
  - 1.8英寸（便携设备）
- **容量范围**：30GB到3TB每驱动器
- **转速**：60到250转/秒（RPM）

#### 性能指标

**传输速率**
- **理论传输速率**：6 Gb/s
- **实际有效传输速率**：约1 Gb/s

**寻道时间（Seek Time）**
- 范围：3ms到12ms
- 桌面驱动器常见：9ms
- 平均寻道时间通常按1/3磁道数计算

**旋转延迟（Rotational Latency）**
- 计算公式：`延迟 = 60 / RPM`（秒）
- 平均延迟 = 1/2 × 延迟
- 例如：7200 RPM磁盘
  - 延迟 = 60/7200 = 0.00833秒 = 8.33ms
  - 平均延迟 = 4.17ms

**访问延迟（Access Latency）**
```
平均访问时间 = 平均寻道时间 + 平均旋转延迟
```
- 最快磁盘：3ms + 2ms = 5ms
- 慢速磁盘：9ms + 5.56ms = 14.56ms

**平均I/O时间**
```
平均I/O时间 = 平均访问时间 + (传输数据量 / 传输速率) + 控制器开销
```

**示例计算**：
- 传输4KB块
- 7200 RPM磁盘
- 5ms平均寻道时间
- 1Gb/s传输速率
- 0.1ms控制器开销

计算过程：
1. 平均访问时间 = 5ms + 4.17ms = 9.17ms
2. 传输时间 = 4KB / (1Gb/s) = 4KB / (128MB/s) = 0.031ms
3. 平均I/O时间 = 9.17ms + 0.031ms + 0.1ms = 9.301ms

#### 磁盘寻址

**逻辑块地址（LBA - Logical Block Address）**
- 磁盘被寻址为大的1维逻辑块数组
- 逻辑块是传输的最小单位
- 低级格式化在物理介质上创建逻辑块

**地址映射**
- 扇区0是最外层柱面第一个磁道的第一个扇区
- 映射顺序：
  1. 先完成一个磁道的所有扇区
  2. 然后完成该柱面的其余磁道
  3. 最后从外到内完成所有柱面

**特殊情况**
- 坏扇区需要特殊处理
- 恒定角速度（CAV）导致每磁道扇区数不恒定

#### 磁头碰撞（Head Crash）
- 当磁盘磁头与盘片表面接触时发生
- 这是非常严重的问题，可能导致数据丢失和硬件损坏
- 现代硬盘有保护机制防止这种情况

#### 可移动磁盘
- 某些磁盘设计为可移动的
- 允许在不同系统间传输数据

---

### 2. 非易失性存储器（NVM - Nonvolatile Memory）

#### 基本概念
- 如果像磁盘驱动器一样使用，称为**固态硬盘（SSD - Solid-State Disks）**
- 其他形式包括：
  - USB驱动器（U盘、闪存盘）
  - DRAM磁盘替代品
  - 主板表面安装的存储
  - 智能手机等设备的主存储

#### NVM的特点

**优势**
- 比HDD更可靠（无移动部件）
- 速度快得多（无寻道时间和旋转延迟）
- 可直接连接到PCI总线（NVMe）

**劣势**
- 每MB更昂贵
- 可能寿命更短（需要仔细管理）
- 容量较小

#### NAND闪存的挑战

**读写特性**
- 按"页"（page）增量读写（类似扇区）
- **不能原地覆盖**：必须先擦除才能写入
- 擦除以更大的"块"（block）为单位进行

**寿命限制**
- 每个单元只能擦除有限次数（约100,000次）
- 寿命用**每日驱动写入量（DWPD - Drive Writes Per Day）**衡量
- 示例：1TB NAND驱动器，5DWPD评级
  - 在保修期内每天可写入5TB而不会失效

#### NAND闪存控制器算法

**1. 闪存转换层（FTL - Flash Translation Layer）**
- 跟踪哪些逻辑块是有效的
- 维护FTL表来管理逻辑到物理地址的映射
- 处理无效数据页的问题

**2. 垃圾回收（Garbage Collection）**
- 释放无效页空间
- 当块中有有效和无效页混合时，需要：
  - 读取有效页
  - 写入新位置
  - 擦除整个块

**3. 过度配置（Overprovisioning）**
- 分配额外空间为GC提供工作空间
- 提高性能和寿命

**4. 磨损均衡（Wear Leveling）**
- 每个单元有寿命限制
- 需要均匀写入所有单元
- 防止某些单元过早磨损

**NAND块结构示例**：
```
┌─────────────────────────┐
│  有效页 │ 无效页 │ 有效页 │
│  有效页 │ 无效页 │ 无效页 │
│  无效页 │ 有效页 │ 有效页 │
└─────────────────────────┘
需要垃圾回收来整理
```

#### NVMe接口
- **NVM Express（NVMe）**：专为NVM设计的高速接口
- 直接连接到PCI总线
- 比传统SATA接口快得多

---

### 3. 易失性内存（RAM驱动器）

#### 基本概念
- DRAM经常用作大容量存储设备
- 技术上不是辅助存储（因为易失性），但可以有文件系统
- 可以像非常快的辅助存储一样使用

#### RAM驱动器的特点
- 也称为RAM磁盘
- 作为原始块设备呈现
- 通常格式化为文件系统

#### 为什么需要RAM驱动器？
- 计算机已经有缓冲和缓存（通过RAM）
- 区别在于：
  - **缓存/缓冲区**：由程序员、操作系统、硬件分配和管理
  - **RAM驱动器**：在用户控制下

#### 系统支持
- **Linux**：`/dev/ram`设备
- **macOS**：使用`diskutil`创建
- **Linux tmpfs**：`/tmp`文件系统类型为tmpfs

#### 用途
- 高速临时存储
- 程序可以通过读写RAM驱动器快速共享大量数据
- 适合需要极快I/O速度的应用

---

### 4. 磁盘结构

#### 逻辑块寻址
- 磁盘驱动器被寻址为大的1维逻辑块数组
- 逻辑块是传输的最小单位
- 低级格式化在物理介质上创建逻辑块

#### 地址映射过程
1. 扇区0是最外层柱面第一个磁道的第一个扇区
2. 映射按顺序进行：
   - 先完成该磁道的所有扇区
   - 然后完成该柱面的其余磁道
   - 最后从外到内完成所有柱面

#### 特殊情况处理
- **坏扇区**：需要特殊处理，不能用于存储
- **恒定角速度（CAV）**：导致每磁道扇区数不恒定
  - 外圈磁道有更多扇区
  - 内圈磁道扇区较少

---

### 5. 磁盘连接

#### 主机连接存储
- 通过I/O端口访问，与I/O总线通信
- 可用总线类型：
  - **ATA**（Advanced Technology Attachment）
  - **SATA**（Serial ATA）
  - **eSATA**（External SATA）
  - **SAS**（Serial Attached SCSI）
  - **USB**（Universal Serial Bus）
  - **FC**（Fibre Channel）
- **最常见**：SATA

#### 控制器
- **主机控制器**：计算机端的控制器
- **设备控制器**：设备端的控制器
- 也称为**主机总线适配器（HBA - Host-Bus Adapters）**

#### 数据传输过程
1. 计算机通过内存映射I/O端口在主机控制器上放置命令
2. 主机控制器向设备控制器发送消息
3. 数据通过**DMA（Direct Memory Access）**在设备和计算机DRAM之间传输
4. DMA允许设备直接访问内存，无需CPU干预

#### NVMe
- 因为NVM比HDD快得多，需要新的快速接口
- **NVMe**直接连接到PCI总线
- 提供比SATA更高的性能

---

## 磁盘调度算法

### 为什么需要磁盘调度？

#### 操作系统职责
- 操作系统负责高效使用硬件
- 对于磁盘驱动器，这意味着：
  - **快速访问时间**
  - **高磁盘带宽**

#### 性能指标
- **寻道时间**：移动磁头到所需柱面的时间
  - 寻道时间 ≈ 寻道距离
- **磁盘带宽**：传输的总字节数 / 从第一个服务请求到完成最后一次传输的总时间

### 磁盘I/O请求来源
1. **操作系统**：系统进程
2. **用户进程**：应用程序

### I/O请求内容
- 输入或输出模式
- 磁盘地址
- 内存地址
- 要传输的扇区数

### 请求队列管理
- 操作系统为每个磁盘或设备维护请求队列
- **空闲磁盘**：可以立即处理I/O请求
- **忙碌磁盘**：工作必须排队
- **优化算法**：只有在队列存在时才有意义

### 调度算法演进
- **过去**：操作系统负责队列管理和磁盘磁头调度
- **现在**：内置到存储设备和控制器中
- 操作系统只需提供**逻辑块地址（LBA）**来处理请求

---

### 1. FCFS（First-Come-First-Served，先来先服务）

#### 算法描述
- 按照请求到达的顺序处理
- 最简单的调度算法
- 公平但效率可能较低

#### 示例
假设请求队列：98, 183, 37, 122, 14, 124, 65, 67
当前磁头位置：53

执行顺序：
1. 53 → 98（移动45个柱面）
2. 98 → 183（移动85个柱面）
3. 183 → 37（移动146个柱面）
4. 37 → 122（移动85个柱面）
5. 122 → 14（移动108个柱面）
6. 14 → 124（移动110个柱面）
7. 124 → 65（移动59个柱面）
8. 65 → 67（移动2个柱面）

**总磁头移动**：45 + 85 + 146 + 85 + 108 + 110 + 59 + 2 = **640个柱面**

#### 优缺点
- **优点**：简单、公平、易于实现
- **缺点**：不考虑磁头当前位置，可能导致大量不必要的移动

---

### 2. SCAN（电梯算法）

#### 算法描述
- 磁头从磁盘一端开始，向另一端移动
- 在移动过程中服务所有请求
- 到达另一端后，磁头移动方向反转
- 继续服务请求
- 类似电梯的工作原理

#### 示例
假设请求队列：98, 183, 37, 122, 14, 124, 65, 67
当前磁头位置：53
方向：向右（从小到大）

执行顺序（向右移动）：
1. 53 → 65（移动12个柱面）
2. 65 → 67（移动2个柱面）
3. 67 → 98（移动31个柱面）
4. 98 → 122（移动24个柱面）
5. 122 → 124（移动2个柱面）
6. 124 → 183（移动59个柱面）
7. 到达最右端，反转方向

执行顺序（向左移动）：
8. 183 → 37（移动146个柱面）
9. 37 → 14（移动23个柱面）

**总磁头移动**：12 + 2 + 31 + 24 + 2 + 59 + 146 + 23 = **299个柱面**

#### 优缺点
- **优点**：
  - 比FCFS更高效
  - 等待时间更均匀
- **缺点**：
  - 如果请求密度均匀，另一端等待时间最长
  - 可能产生饥饿（虽然较少）

---

### 3. C-SCAN（Circular SCAN，循环SCAN）

#### 算法描述
- 磁头从一端移动到另一端，服务请求
- 到达另一端后，**立即返回到起始端**（返回时不服务请求）
- 将柱面视为循环列表，从最后一个柱面绕回到第一个

#### 示例
假设请求队列：98, 183, 37, 122, 14, 124, 65, 67
当前磁头位置：53
方向：向右

执行顺序（向右移动）：
1. 53 → 65（移动12个柱面）
2. 65 → 67（移动2个柱面）
3. 67 → 98（移动31个柱面）
4. 98 → 122（移动24个柱面）
5. 122 → 124（移动2个柱面）
6. 124 → 183（移动59个柱面）
7. 到达最右端，立即返回到0（移动183个柱面，但不服务请求）

执行顺序（从0开始向右）：
8. 0 → 14（移动14个柱面）
9. 14 → 37（移动23个柱面）

**总磁头移动**：12 + 2 + 31 + 24 + 2 + 59 + 183 + 14 + 23 = **350个柱面**

#### 优缺点
- **优点**：
  - 提供比SCAN更均匀的等待时间
  - 所有请求的等待时间更一致
- **缺点**：
  - 返回行程浪费（但通常很快）

---

### 4. 选择磁盘调度算法

#### 算法比较
- **FCFS**：常见且自然，但效率较低
- **SCAN和C-SCAN**：在磁盘负载重的系统中表现更好
  - 减少饥饿，但仍可能发生

#### Linux的Deadline调度器

**设计目标**：避免饥饿

**队列结构**：
- 维护独立的读队列和写队列
- **读优先**：因为进程更可能在读操作上阻塞

**四种队列**：
1. **读队列（LBA顺序）**：按逻辑块地址排序，实现C-SCAN
2. **写队列（LBA顺序）**：按逻辑块地址排序，实现C-SCAN
3. **读队列（FCFS顺序）**：按先来先服务排序
4. **写队列（FCFS顺序）**：按先来先服务排序

**调度策略**：
- 所有I/O请求按队列顺序批量发送
- 每批后，检查FCFS队列中是否有超过配置年龄的请求（默认500ms）
- 如果有，选择包含该请求的LBA队列进行下一批I/O

**其他调度器**：
- **NOOP**：无调度
- **CFQ（Completely Fair Queueing）**：完全公平队列
- 在Red Hat Enterprise Linux (RHEL) 7中，默认值因存储设备而异

---

## NVM调度

### NVM的特点
- **无磁头**：不需要寻道
- **无旋转延迟**：没有旋转的盘片
- 但仍需要优化

### RHEL 7中的NVM调度
- 使用**NOOP（无调度）**
- 但会**合并相邻的LBA请求**

### NVM vs HDD性能

#### 随机I/O vs 顺序I/O
- **NVM**：最擅长随机I/O
- **HDD**：最擅长顺序I/O

#### 吞吐量
- 吞吐量可能相似
- 但**IOPS（每秒输入/输出操作数）**差异巨大：
  - **NVM**：数十万IOPS
  - **HDD**：数百IOPS

#### 写入放大（Write Amplification）
- **问题**：一次写入可能导致垃圾回收和多次读/写
- **影响**：可能降低NVM的性能优势
- **原因**：
  1. 写入需要擦除块
  2. 擦除前需要移动有效数据
  3. 导致额外的读写操作

---

## 错误检测与纠正

### 基本概念
- 错误检测和纠正是计算的许多部分（内存、网络、存储）的基本方面

### 错误检测

#### 目的
- 确定是否发生了问题（例如位翻转）

#### 方法

**1. 奇偶校验位（Parity Bit）**
- 奇偶校验是校验和的一种形式
- 使用模运算计算、存储、比较固定长度字的值
- 简单但只能检测奇数个错误

**2. 循环冗余校验（CRC - Cyclic Redundancy Check）**
- 常见于网络
- 使用哈希函数检测多位错误
- 比奇偶校验更强大

### 错误纠正

#### 错误纠正码（ECC - Error-Correction Code）
- 不仅检测错误，还能纠正某些错误
- **软错误**：可纠正（临时性错误）
- **硬错误**：可检测但不可纠正（永久性硬件故障）

#### ECC的应用
- 内存模块（ECC内存）
- 存储设备
- 网络传输

---

## 存储设备管理

### 1. 低级格式化（Low-Level Formatting）

#### 定义
- 也称为**物理格式化（Physical Formatting）**
- 将磁盘划分为扇区，磁盘控制器可以读写

#### 扇区结构
每个扇区包含：
- **头部信息**：扇区标识、地址等
- **数据**：实际存储的数据（通常512字节，但可选择）
- **错误纠正码（ECC）**：用于检测和纠正错误

### 2. 分区（Partitioning）

#### 定义
- 将磁盘划分为一个或多个柱面组
- 每个组被视为**逻辑磁盘**

#### 用途
- 分离不同的操作系统
- 分离不同的文件系统
- 原始访问（用于数据库等）

### 3. 逻辑格式化（Logical Formatting）

#### 定义
- 也称为"创建文件系统"
- 操作系统在分区上记录自己的数据结构

#### 簇（Clusters）
- 大多数文件系统将块分组为**簇**以提高效率
- **磁盘I/O**：以块为单位完成
- **文件I/O**：以簇为单位完成

### 4. 引导过程（Booting）

#### 根分区
- 包含操作系统
- 其他分区可以包含：
  - 其他操作系统
  - 其他文件系统
  - 原始分区

#### 挂载（Mounting）
- **启动时挂载**：根分区在启动时挂载
- **自动挂载**：其他分区可以自动挂载
- **手动挂载**：也可以手动挂载

#### 挂载时检查
- 检查文件系统一致性
- 所有元数据是否正确？
  - 如果否：修复，重试
  - 如果是：添加到挂载表，允许访问

#### 引导块（Boot Block）
- 可以指向引导卷或引导加载程序
- 引导加载程序：包含足够代码的块集，知道如何从文件系统加载内核
- 或用于多操作系统引导的引导管理程序

### 5. 原始磁盘访问（Raw Disk Access）

#### 用途
- 应用程序想要自己进行块管理
- 让操作系统不参与（例如数据库）

#### 优势
- 完全控制
- 可能获得更好的性能
- 适合需要直接控制存储的应用

### 6. 主引导记录（MBR - Master Boot Record）

#### 定义
- 分区计算机大容量存储设备（如固定磁盘或可移动驱动器）第一个块中的引导扇区类型

#### 功能
- 引导块初始化系统
- 引导程序存储在ROM、固件中
- 引导加载程序程序存储在引导分区的引导块中

### 7. 坏块处理

#### 方法：扇区备用（Sector Sparing）
- 检测到坏扇区时
- 将数据重映射到备用扇区
- 对操作系统透明

#### Windows中的引导
- 可以从辅助存储引导
- 支持多种引导配置

---

## 交换空间管理

### 基本概念

#### 用途
- 当DRAM不够大，无法容纳所有进程时使用
- **交换（Swapping）**：移动整个进程
- **分页（Paging）**：移动页面

#### 操作系统职责
- 操作系统提供交换空间管理
- 管理从DRAM到辅助存储的数据移动

### 性能考虑

#### 速度差异
- 辅助存储比DRAM慢得多
- **优化性能非常重要**

#### 优化策略
- **多个交换空间**：可能减少任何给定设备上的I/O负载
- **专用设备**：最好有专用设备
- **位置**：
  - 原始分区中
  - 文件系统中的文件（便于添加）

### Linux系统中的交换数据结构
- Linux维护交换空间的数据结构
- 跟踪哪些页面在交换空间中
- 管理交换空间的分配和释放

---

## 存储连接方式

### 1. 主机连接存储（Host-Attached Storage）

#### 基本概念
- 通过本地I/O端口访问
- 使用多种技术之一

#### 连接技术
- **USB**：通用串行总线
- **FireWire**：IEEE 1394
- **Thunderbolt**：高速接口
- **光纤通道（FC）**：高端系统使用
  - 高速串行架构
  - 使用光纤或铜缆
  - 多个主机和存储设备可以连接到FC结构

#### 数据传输
- 通过**DMA（直接内存访问）**进行
- 允许设备直接访问内存，无需CPU干预

---

### 2. 网络附加存储（NAS - Network-Attached Storage）

#### 基本概念
- 通过网络而非本地连接（如总线）提供存储
- 远程附加到文件系统

#### 协议

**文件系统级别**：
- **NFS（Network File System）**：网络文件系统
- **CIFS（Common Internet File System）**：通用互联网文件系统
  - 也称为SMB（Server Message Block）

**实现方式**：
- 通过**远程过程调用（RPC）**实现
- 主机和存储之间
- 通常在IP网络上的TCP或UDP

**块级别**：
- **iSCSI协议**：使用IP网络承载SCSI协议
- 远程附加到设备（块）

#### 优缺点
- **优点**：
  - 易于共享
  - 集中管理
  - 可扩展
- **缺点**：
  - 使用网络带宽
  - 可能有延迟

---

### 3. 云存储（Cloud Storage）

#### 基本概念
- 类似于NAS，通过网络提供存储访问
- 与NAS不同：通过Internet或WAN访问远程数据中心

#### 访问方式
- **NAS**：呈现为另一个文件系统
- **云存储**：基于API，程序使用API提供访问

#### 为什么使用API？
- **延迟**：网络延迟可能很高
- **故障场景**：网络可能不稳定
- NAS协议在这种情况下效果不佳

#### 示例
- **Dropbox**：文件同步和共享
- **Amazon S3**：简单存储服务
- **Microsoft OneDrive**：微软云存储
- **Apple iCloud**：苹果云存储

#### 特点
- 可扩展
- 按需付费
- 高可用性
- 地理分布

---

### 4. 存储阵列（Storage Array）

#### 基本概念
- 可以只连接磁盘，或连接磁盘阵列
- 避免NAS使用网络带宽的缺点

#### 组件
- **控制器**：一个或多个
- **端口**：连接主机到阵列
- **内存**：缓存数据
- **控制软件**：有时包括NVRAM等
- **磁盘**：几个到数千个

#### 功能
- **RAID**：冗余磁盘阵列
- **热备**：自动替换故障磁盘
- **热插拔**：无需关闭系统即可更换磁盘
- **共享存储**：提高效率

#### 高级功能（某些文件系统中也有）
- **快照（Snapshots）**：文件系统在某个时间点的视图
- **克隆（Clones）**：快速复制
- **精简配置（Thin Provisioning）**：按需分配空间
- **复制（Replication）**：自动复制数据
- **去重（Deduplication）**：消除重复数据
- 等等

---

### 5. 存储区域网络（SAN - Storage Area Network）

#### 基本概念
- 常见于大型存储环境
- 多个主机连接到多个存储阵列
- **非常灵活**

#### 结构
- SAN是一个或多个存储阵列
- 连接到一个或多个：
  - **光纤通道交换机**
  - **InfiniBand（IB）网络**
- 主机也连接到交换机

#### 存储分配
- 通过**LUN掩码（LUN Masking）**使存储可用
- 从特定阵列到特定服务器
- 易于添加或删除存储
- 添加新主机并为其分配存储

#### 为什么有独立的存储网络？
- **考虑因素**：
  - **iSCSI**：在IP网络上运行SCSI
  - **FCOE（Fibre Channel over Ethernet）**：以太网上的光纤通道
- **优势**：
  - 专用网络，不影响常规网络流量
  - 更高的性能和可靠性
  - 更好的安全性

#### SAN vs NAS
- **SAN**：块级别访问，高性能
- **NAS**：文件级别访问，易于使用

---

## RAID结构

### RAID基本概念

#### 定义
- **RAID**：**R**edundant **A**rray of **I**nexpensive **D**isks
  - 冗余廉价磁盘阵列
- 现在也解释为**I**ndependent（独立）

#### 目的
- **可靠性**：通过冗余提供可靠性
- **性能**：提高性能
- **容量**：增加存储容量

### RAID的可靠性

#### 平均故障时间（MTTF - Mean Time To Failure）
- 多个磁盘驱动器提供可靠性
- 通过冗余增加平均故障时间

#### 平均修复时间（MTTR - Mean Time To Repair）
- 暴露时间：另一个故障可能导致数据丢失的时间

#### 平均数据丢失时间（MTTDL - Mean Time To Data Loss）
- 基于上述因素
- 如果镜像磁盘独立故障：
  - 考虑磁盘：100,000小时平均故障时间
  - 10小时平均修复时间
  - 平均数据丢失时间 = 100,000² / (2 × 10) = 500 × 10⁶小时
  - **约57,000年！**

#### 性能提升
- 经常与**NVRAM**结合以提高写入性能
- NVRAM作为写入缓存

### RAID级别概述
- RAID排列为**六个不同级别**（实际上更多）
- 每个级别提供不同的冗余和性能特征

---

### RAID 0：磁盘条带化（Disk Striping）

#### 定义
- 将数据体分成块的过程
- 将数据块分布在多个存储设备上
- 如HDD或SSD，在RAID组中

#### 特点
- **无冗余**：不提供数据保护
- **性能提升**：通过并行访问提高性能
- **容量**：总容量 = 所有磁盘容量之和

#### 适用场景
- 需要高性能
- 数据丢失可接受
- 临时数据

#### 图示
```
数据块: A1 A2 A3 A4 A5 A6 A7 A8
磁盘1:  A1    A3    A5    A7
磁盘2:     A2    A4    A6    A8
```

---

### RAID 1：镜像（Mirroring）

#### 定义
- 在两个或多个磁盘上保持一组数据的完全副本（或镜像）
- 经典RAID 1镜像对包含两个磁盘

#### 特点
- **无奇偶校验**：不使用奇偶校验
- **无条带化**：不条带化数据
- **无跨磁盘空间**：数据在所有属于阵列的磁盘上镜像
- **容量限制**：数组只能与最小的成员磁盘一样大

#### 适用场景
- **读性能**或**可靠性**比写性能或结果数据存储容量更重要时有用

#### 优势
- 高可靠性
- 读性能好（可以从任一磁盘读取）
- 简单

#### 劣势
- 写性能较低（需要写入两个磁盘）
- 容量利用率低（50%）

#### 图示
```
磁盘1: A1 A2 A3 A4
磁盘2: A1 A2 A3 A4  (完全镜像)
```

---

### RAID 0+1 和 RAID 1+0

#### RAID 1+0（条带化镜像）
- 首先镜像，然后条带化
- 也称为**镜像条带**

#### RAID 0+1（镜像条带）
- 首先条带化，然后镜像
- 也称为**条带镜像**

#### 特点
- **高性能**：通过条带化
- **高可靠性**：通过镜像
- 至少需要4个磁盘

#### 区别
- **RAID 1+0**：通常更优，因为单个磁盘故障只影响一个条带
- **RAID 0+1**：单个磁盘故障可能影响整个条带组

#### 图示（RAID 1+0）
```
条带组1:        条带组2:
磁盘1: A1 A3    磁盘3: B1 B3
磁盘2: A1 A3    磁盘4: B1 B3  (镜像)
磁盘1: A2 A4    磁盘3: B2 B4
磁盘2: A2 A4    磁盘4: B2 B4  (镜像)
```

---

### RAID 2：位级条带化

#### 定义
- 在多个磁盘上按位分割数据
- 与大多数RAID级别不同，后者将数据分成块

#### 特点
- 使用称为**汉明码（Hamming Code）**的错误纠正类型
- 引入冗余以检测和纠正存储数据中的错误
- 硬盘驱动器由控制器同步，因此它们同步旋转
- 同时到达同一位置

#### 限制
- 由于同步，系统通常一次只处理一个读或写请求
- 限制其同时处理多个操作的能力

#### 现状
- **很少使用**：在实践中很少使用
- 太复杂，性能不佳

---

### RAID 3：字节级条带化

#### 定义
- 由字节级条带化组成
- 带有**专用奇偶校验磁盘**

#### 特点
- **一般不能同时服务多个请求**
- 因为任何单个数据块都会：
  - 根据定义分布在集合的所有成员上
  - 驻留在每个磁盘上的相同物理位置
- 因此，任何I/O操作都需要每个磁盘上的活动
- 通常需要**同步主轴**

#### 现状
- **很少使用**：在实践中很少使用
- 性能限制太大

---

### RAID 4：块级条带化，专用奇偶校验

#### 定义
- 由块级条带化组成
- 带有**专用奇偶校验磁盘**

#### 特点
- **随机读性能好**：可以从任何数据磁盘读取
- **随机写性能低**：由于需要将所有奇偶校验数据写入单个磁盘
- 除非文件系统是RAID-4感知的并补偿

#### 奇偶校验计算
- 奇偶校验 = 数据块1 XOR 数据块2 XOR 数据块3 ...
- 存储在专用奇偶校验磁盘上

#### 图示
```
磁盘1: A1 A4 A7
磁盘2: A2 A5 A8
磁盘3: A3 A6 A9
奇偶校验: P1 P2 P3  (P1 = A1 XOR A2 XOR A3)
```

---

### RAID 5：块级条带化，分布式奇偶校验

#### 定义
- 由块级条带化组成
- **分布式奇偶校验**：与RAID 4不同，奇偶校验信息分布在驱动器之间

#### 特点
- 要求除一个之外的所有驱动器都存在才能运行
- 单个驱动器故障后，后续读取可以从分布式奇偶校验计算
- 这样不会丢失数据
- **至少需要三个磁盘**

#### 优势
- 比RAID 4更好的写性能（奇偶校验分布在所有磁盘上）
- 良好的读性能
- 可以容忍单个磁盘故障

#### 劣势
- 写操作需要读取旧数据和奇偶校验，计算新奇偶校验，然后写入
- 这导致**写惩罚（Write Penalty）**

#### 图示
```
磁盘1: A1 A2 P1
磁盘2: A3 P2 A4
磁盘3: P3 A5 A6
(P1 = A1 XOR A3, P2 = A2 XOR A4, P3 = A3 XOR A5)
```

---

### RAID 6：双分布式奇偶校验

#### 定义
- 通过添加第二个奇偶校验块扩展RAID 5
- 使用块级条带化
- **两个奇偶校验块**分布在所有成员磁盘上

#### 特点
- **至少需要四个磁盘**
- 可以容忍**两个磁盘故障**
- 比RAID 5更高的可靠性

#### 优势
- 非常高的可靠性
- 可以容忍两个同时故障

#### 劣势
- 写惩罚更高（需要计算和写入两个奇偶校验）
- 容量利用率更低

#### 适用场景
- 需要极高可靠性的环境
- 大型存储系统
- 关键任务应用

---

### RAID的其他特性

#### 1. 快照（Snapshots）
- 文件系统在一组更改发生之前的视图
- 即某个时间点的视图
- 更多内容在第12章

#### 2. 复制（Replication）
- 在独立站点之间自动复制写入
- 用于冗余和灾难恢复
- 可以是：
  - **同步**：写入必须等待复制完成
  - **异步**：写入立即返回，复制在后台进行

#### 3. 热备盘（Hot Spare Disk）
- 未使用的磁盘
- 如果磁盘故障，RAID生产自动使用
- 替换故障磁盘并重建RAID集（如果可能）
- **减少平均修复时间**

---

### RAID扩展：ZFS

#### 问题
- RAID本身不能防止或检测数据损坏或其他错误
- 只能防止磁盘故障

#### ZFS解决方案
- **Solaris ZFS**添加了所有数据和元数据的校验和
- 校验和与指向对象的指针一起保存
- 检测对象是否正确以及是否已更改
- 可以检测和纠正数据和元数据损坏

#### ZFS的其他特性
- **移除卷和分区**：
  - 磁盘在池中分配
  - 文件系统与池共享该池
  - 像`malloc()`和`free()`内存分配/释放调用一样使用和释放空间

#### ZFS校验和
- ZFS校验所有元数据和数据
- 提供端到端的数据完整性

---

### 传统存储 vs 池化存储

#### 传统存储
- 固定分区
- 每个文件系统有固定大小
- 难以调整大小

#### 池化存储（ZFS方法）
- 所有磁盘在一个池中
- 文件系统共享池
- 动态分配和释放空间
- 更灵活、更高效

---

## 对象存储

### 基本概念

#### 问题
- 通用计算中，文件系统对于非常大的规模不够
- 需要另一种方法

#### 解决方案：对象存储
- 从存储池开始
- 将对象放入其中

### 对象的特点

#### 定义
- **对象**：只是数据容器
- **无导航方式**：无法导航池以查找对象
  - 无目录结构
  - 很少服务
- **计算机导向**：不是用户导向

### 典型序列

1. **创建对象**：在池中创建对象，接收对象ID
2. **访问对象**：通过该ID访问对象
3. **删除对象**：通过该ID删除对象

### 对象存储管理软件

#### 示例
- **Hadoop文件系统（HDFS）**
- **Ceph**

#### 功能
- 确定存储对象的位置
- 管理保护
- 通常通过存储N个副本，跨N个系统，在对象存储集群中

### 对象存储的特点

- **水平可扩展**：可以轻松添加更多节点
- **内容寻址**：通过内容哈希寻址
- **非结构化**：不需要预定义的模式

### 对象存储 vs 文件系统

| 特性 | 文件系统 | 对象存储 |
|------|----------|----------|
| 访问方式 | 目录路径 | 对象ID |
| 结构 | 层次结构 | 扁平结构 |
| 规模 | 有限 | 几乎无限 |
| 元数据 | 有限 | 丰富 |
| 用途 | 通用 | 大规模、云存储 |

---

## 性能计算

### 硬盘性能计算示例

#### 给定参数
- 传输4KB块
- 7200 RPM磁盘
- 5ms平均寻道时间
- 1Gb/s传输速率
- 0.1ms控制器开销

#### 计算步骤

**1. 平均旋转延迟**
```
延迟 = 60 / RPM = 60 / 7200 = 0.00833秒 = 8.33ms
平均延迟 = 延迟 / 2 = 8.33 / 2 = 4.17ms
```

**2. 平均访问时间**
```
平均访问时间 = 平均寻道时间 + 平均旋转延迟
             = 5ms + 4.17ms
             = 9.17ms
```

**3. 传输时间**
```
传输速率 = 1Gb/s = 128MB/s = 131,072KB/s
传输时间 = 4KB / 131,072KB/s
         = 0.0000305秒
         = 0.0305ms
```

**4. 平均I/O时间**
```
平均I/O时间 = 平均访问时间 + 传输时间 + 控制器开销
            = 9.17ms + 0.0305ms + 0.1ms
            = 9.301ms
```

### 性能优化建议

#### 对于HDD
1. **减少寻道时间**：使用适当的调度算法
2. **减少旋转延迟**：优化数据布局
3. **批量传输**：一次传输更多数据

#### 对于NVM
1. **减少写入放大**：优化写入模式
2. **磨损均衡**：确保均匀使用
3. **垃圾回收优化**：减少GC开销

---

## 历史背景

### 第一个商业磁盘驱动器

#### IBM RAMDAC（1956年）
- **IBM Model 350磁盘存储系统**
- **容量**：5M（7位）字符
- **规格**：
  - 50个24英寸盘片
  - 访问时间 < 1秒
- **历史意义**：开创了磁盘存储时代

### 现代发展
- 从1956年的5MB到现在的数TB
- 从24英寸盘片到2.5英寸和更小
- 从机械到固态
- 性能提升数千倍

---

## 总结

### 关键概念

1. **存储层次结构**
   - 从快速、昂贵、小容量（CPU缓存）
   - 到慢速、便宜、大容量（磁带）

2. **性能因素**
   - **HDD**：寻道时间、旋转延迟、传输速率
   - **NVM**：写入放大、磨损均衡、垃圾回收

3. **调度算法**
   - FCFS：简单但效率低
   - SCAN：更高效，等待时间均匀
   - C-SCAN：最均匀的等待时间

4. **可靠性**
   - RAID提供冗余
   - 不同级别提供不同的可靠性/性能权衡

5. **连接方式**
   - 主机连接：直接、快速
   - 网络连接：灵活、可共享
   - 云存储：可扩展、按需

### 实际应用

- **数据库**：需要高性能I/O，可能使用原始磁盘访问
- **文件服务器**：使用NAS或SAN
- **云服务**：使用对象存储
- **个人电脑**：使用主机连接的HDD或SSD
- **企业存储**：使用RAID阵列和SAN

### 未来趋势

1. **NVM技术发展**
   - 更高容量
   - 更低成本
   - 更长寿命

2. **存储虚拟化**
   - 软件定义存储
   - 更灵活的管理

3. **云存储增长**
   - 更多数据迁移到云
   - 混合云存储

4. **性能优化**
   - 更好的调度算法
   - 更智能的缓存策略

---

## 学习要点

### 必须理解的概念

1. **磁盘结构**：磁道、扇区、柱面
2. **性能指标**：寻道时间、旋转延迟、传输速率
3. **调度算法**：FCFS、SCAN、C-SCAN
4. **RAID级别**：0、1、5、6的特点和用途
5. **存储连接**：主机连接、NAS、SAN、云存储

### 必须掌握的计算

1. **平均旋转延迟** = 60 / (2 × RPM)
2. **平均访问时间** = 平均寻道时间 + 平均旋转延迟
3. **平均I/O时间** = 平均访问时间 + 传输时间 + 控制器开销
4. **RAID可靠性**：MTTDL计算

### 实际应用场景

1. **选择存储设备**：HDD vs SSD
2. **选择RAID级别**：根据需求选择
3. **优化I/O性能**：选择合适的调度算法
4. **设计存储架构**：主机连接 vs 网络连接

---

*本文档基于《操作系统概念》第10版第11章内容整理*

