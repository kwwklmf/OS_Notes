# 第3章：进程（第二部分）- 详细讲解

## 目录
1. [消息传递（Message Passing）](#消息传递)
2. [直接通信（Direct Communication）](#直接通信)
3. [间接通信（Indirect Communication）](#间接通信)
4. [同步和异步（Synchronization）](#同步和异步)
5. [缓冲（Buffering）](#缓冲)
6. [POSIX共享内存（POSIX Shared Memory）](#posix共享内存)
7. [Mach消息传递（Mach Message Passing）](#mach消息传递)
8. [Windows本地过程调用（Windows LPC）](#windows本地过程调用)
9. [管道（Pipes）](#管道)
10. [套接字（Sockets）](#套接字)
11. [远程过程调用（RPC）](#远程过程调用)
12. [竞争条件（Race Condition）](#竞争条件)

---

## 消息传递（Message Passing）

### 1. 什么是消息传递？

#### 基本定义
- **进程通过消息传递通信**，而不使用共享变量
- **IPC设施提供两个操作**：
  - **send(message)**：发送消息
  - **receive(message)**：接收消息

#### 消息大小
- **固定大小**：所有消息大小相同
- **可变大小**：消息大小可以不同

### 2. 消息传递的实现问题

#### 如果进程P和Q想要通信，它们需要：

**① 建立通信链接（Establish a Communication Link）**
- 在它们之间建立通信链接
- 通过send/receive交换消息

**② 实现问题（Implementation Issues）**

**a) 链接如何建立？**
- 自动建立还是手动建立？

**b) 一个链接可以关联多个进程吗？**
- 两个进程之间可以有多个链接吗？

**c) 每对通信进程之间可以有多少个链接？**
- 一个还是多个？

**d) 链接的容量是多少？**
- 可以容纳多少消息？

**e) 链接可以容纳的消息大小是固定的还是可变的？**
- 固定大小还是可变大小？

**f) 链接是单向的还是双向的？**
- 只能一个方向还是两个方向？

### 3. 通信链接的实现

#### 物理实现

**① 共享内存（Shared Memory）**
- 进程共享内存区域
- 通过内存传递消息

**② 硬件总线（Hardware Bus）**
- 通过硬件总线通信
- 例如：PCI总线

**③ 网络（Network）**
- 通过网络通信
- 例如：TCP/IP

#### 逻辑实现

**① 直接或间接（Direct or Indirect）**
- **直接**：进程直接指定目标进程
- **间接**：通过邮箱（Mailbox）或端口（Port）

**② 同步或异步（Synchronous or Asynchronous）**
- **同步**：阻塞操作
- **异步**：非阻塞操作

**③ 自动或显式缓冲（Automatic or Explicit Buffering）**
- **自动**：操作系统自动缓冲
- **显式**：进程自己管理缓冲

---

## 直接通信（Direct Communication）

### 1. 基本概念

#### 定义
- **进程必须明确命名彼此**
- **直接指定目标进程**

#### 操作

**① send(P, message)**
- **向进程P发送消息**
- **P是目标进程的标识符**

**② receive(Q, message)**
- **从进程Q接收消息**
- **Q是源进程的标识符**

### 2. 通信链接的属性

#### ① 自动建立链接
- **链接自动建立**
- **不需要显式创建**

#### ② 一对一关联
- **链接与恰好一对通信进程关联**
- **每对进程之间恰好存在一个链接**

#### ③ 方向性
- **链接可能是单向的**
- **但通常是双向的**

### 3. 直接通信的特点

#### 优点
- **简单直接**
- **不需要中间媒介**
- **性能好**

#### 缺点
- **进程必须知道彼此的标识符**
- **耦合度高**
- **难以扩展**

### 4. 例子

```c
// 进程P
send(Q, "Hello from P");

// 进程Q
receive(P, message);
printf("Received: %s\n", message);
```

---

## 间接通信（Indirect Communication）

### 1. 基本概念

#### 定义
- **消息被定向和接收自邮箱（Mailbox）**，也称为端口（Port）
- **每个邮箱有唯一ID**
- **进程只有在共享邮箱时才能通信**

#### 类比理解
想象邮箱是邮局的邮箱：
- **进程** = 寄信人和收信人
- **邮箱** = 邮局邮箱
- **消息** = 信件
- **进程把信放到邮箱，其他进程从邮箱取信**

### 2. 通信链接的属性

#### ① 条件建立
- **只有当进程共享公共邮箱时，链接才建立**

#### ② 多对多关联
- **一个链接可能与多个进程关联**
- **多个进程可以共享同一个邮箱**

#### ③ 多个链接
- **每对进程可能共享多个通信链接**
- **通过不同的邮箱**

#### ④ 方向性
- **链接可能是单向的或双向的**

### 3. 操作

#### 基本操作

**① 创建新邮箱（Create a New Mailbox）**
- 创建新的邮箱（端口）

**② 通过邮箱发送和接收消息（Send and Receive Messages）**
- 通过邮箱发送和接收消息

**③ 删除邮箱（Delete a Mailbox）**
- 删除邮箱

#### 原语定义

**① send(A, message)**
- **向邮箱A发送消息**

**② receive(A, message)**
- **从邮箱A接收消息**

### 4. 邮箱共享问题

#### 问题场景
- **P1、P2和P3共享邮箱A**
- **P1发送消息**
- **P2和P3都接收**
- **谁得到消息？**

#### 解决方案

**① 限制链接关联**
- **允许链接最多与两个进程关联**
- **只有两个进程可以共享邮箱**

**② 互斥接收**
- **一次只允许一个进程执行接收操作**
- **其他进程必须等待**

**③ 系统选择**
- **允许系统任意选择接收者**
- **发送者被通知接收者是谁**

### 5. 间接通信的特点

#### 优点
- **解耦**：进程不需要知道彼此
- **灵活**：多个进程可以共享邮箱
- **可扩展**：易于添加新进程

#### 缺点
- **需要邮箱管理**
- **可能有性能开销**

### 6. 例子

```c
// 创建邮箱
mailbox_id = create_mailbox("shared_mailbox");

// 进程P1
send(mailbox_id, "Hello from P1");

// 进程P2
receive(mailbox_id, message);
printf("P2 received: %s\n", message);

// 进程P3
receive(mailbox_id, message);
printf("P3 received: %s\n", message);
```

---

## 同步和异步（Synchronization）

### 1. 阻塞 vs 非阻塞

#### 阻塞（Blocking）被认为是同步的（Synchronous）

**① 阻塞发送（Blocking Send）**
- **发送者被阻塞**，直到消息被接收
- **发送者等待接收者接收消息**

**② 阻塞接收（Blocking Receive）**
- **接收者被阻塞**，直到消息可用
- **接收者等待消息到达**

#### 非阻塞（Non-blocking）被认为是异步的（Asynchronous）

**① 非阻塞发送（Non-blocking Send）**
- **发送者发送消息并继续**
- **不等待消息被接收**

**② 非阻塞接收（Non-blocking Receive）**
- **接收者接收**：
  - **有效消息**，或
  - **空消息（Null Message）**
- **不等待，立即返回**

### 2. 不同的组合

#### 可能的组合

**① 阻塞发送 + 阻塞接收**
- **发送者等待接收者**
- **接收者等待消息**
- **这是会合（Rendezvous）**
- **最同步的方式**

**② 非阻塞发送 + 阻塞接收**
- **发送者立即返回**
- **接收者等待消息**

**③ 阻塞发送 + 非阻塞接收**
- **发送者等待接收者**
- **接收者立即返回**

**④ 非阻塞发送 + 非阻塞接收**
- **两者都立即返回**
- **最异步的方式**

### 3. 会合（Rendezvous）

#### 定义
- **如果发送和接收都是阻塞的，我们有一个会合**
- **发送者和接收者必须同时准备好**
- **同步点**

#### 类比理解
想象两个人约定见面：
- **发送者** = 一个人到达约定地点
- **接收者** = 另一个人到达约定地点
- **会合** = 两人都到达，开始交换信息
- **如果一个人没到，另一个人必须等待**

### 4. 消息传递的阻塞性

#### 灵活性
- **消息传递可能是阻塞的或非阻塞的**
- **根据系统实现和需求选择**

---

## 生产者-消费者：消息传递

### 1. 基本实现

#### 生产者进程（Producer Process）

```c
message next_produced;

while (true) {
    // 在next_produced中产生一个项目
    /* produce an item in next_produced */
    send(next_produced);
}
```

#### 消费者进程（Consumer Process）

```c
message next_consumed;

while (true) {
    receive(next_consumed);
    // 在next_consumed中消费项目
    /* consume the item in next_consumed */
}
```

### 2. 特点

#### 优势
- **不需要共享内存**
- **更安全**
- **操作系统管理通信**

#### 考虑
- **需要同步机制**
- **可能有性能开销**

---

## 缓冲（Buffering）

### 1. 什么是缓冲？

#### 定义
- **附加到链接的消息队列**
- **临时存储消息**

#### 类比理解
想象缓冲是邮局的临时存储：
- **消息** = 信件
- **缓冲** = 邮局的临时存储箱
- **如果收信人不在，信件暂时存放在邮局**

### 2. 三种实现方式

#### ① 零容量（Zero Capacity）
- **链接上没有消息排队**
- **发送者必须等待接收者（会合）**
- **没有缓冲**
- **最同步的方式**

#### ② 有界容量（Bounded Capacity）
- **有限长度的n条消息**
- **如果链接满了，发送者必须等待**
- **如果链接空了，接收者必须等待**
- **有限缓冲**

#### ③ 无界容量（Unbounded Capacity）
- **无限长度**
- **发送者从不等待**
- **接收者可能等待**
- **无限缓冲**

### 3. 缓冲类型对比

| 类型 | 容量 | 发送者行为 | 接收者行为 | 同步性 |
|------|------|-----------|-----------|--------|
| **零容量** | 0 | 必须等待 | 必须等待 | 完全同步 |
| **有界容量** | n | 满时等待 | 空时等待 | 部分同步 |
| **无界容量** | 无限 | 从不等待 | 空时等待 | 异步 |

### 4. 例子

#### 零容量（会合）
```
发送者 → [无缓冲] → 接收者
发送者必须等待接收者准备好
```

#### 有界容量
```
发送者 → [缓冲: 3/10] → 接收者
如果缓冲满了，发送者等待
如果缓冲空了，接收者等待
```

#### 无界容量
```
发送者 → [缓冲: 无限] → 接收者
发送者从不等待
接收者在缓冲空时等待
```

---

## POSIX共享内存（POSIX Shared Memory）

### 1. 基本概念

#### POSIX
- **可移植操作系统接口（Portable Operating System Interface）**
- **Unix-like系统的标准**

#### 共享内存
- **进程首先创建共享内存段**
- **多个进程可以访问同一块内存**

### 2. POSIX共享内存操作

#### ① 创建共享内存段

```c
shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666);
```

**参数说明**：
- **name**：共享内存段的名称
- **O_CREAT**：如果不存在则创建
- **O_RDWR**：读写权限
- **0666**：文件权限

**也可以用于打开现有段**

#### ② 设置对象大小

```c
ftruncate(shm_fd, 4096);
```

- **设置共享内存段的大小**
- **4096字节（4KB）**

#### ③ 内存映射

```c
ptr = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
```

- **使用mmap()将文件映射到内存**
- **返回指向共享内存对象的指针**

#### ④ 读写共享内存

```c
// 写入
sprintf(ptr, "Hello from producer");

// 读取
printf("Consumer read: %s\n", ptr);
```

- **通过mmap()返回的指针进行读写**
- **直接内存访问**

### 3. POSIX生产者示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/mman.h>

int main() {
    const int SIZE = 4096;
    const char *name = "OS";
    const char *message = "Hello from producer";
    
    int shm_fd;
    void *ptr;
    
    // 创建共享内存对象
    shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666);
    
    // 配置对象大小
    ftruncate(shm_fd, SIZE);
    
    // 内存映射共享内存对象
    ptr = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    
    // 写入共享内存
    sprintf(ptr, "%s", message);
    printf("Producer wrote: %s\n", message);
    
    return 0;
}
```

### 4. POSIX消费者示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/mman.h>

int main() {
    const int SIZE = 4096;
    const char *name = "OS";
    
    int shm_fd;
    void *ptr;
    
    // 打开共享内存对象
    shm_fd = shm_open(name, O_RDONLY, 0666);
    
    // 内存映射共享内存对象
    ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);
    
    // 读取共享内存
    printf("Consumer read: %s\n", (char *)ptr);
    
    // 删除共享内存对象
    shm_unlink(name);
    
    return 0;
}
```

---

## Mach消息传递（Mach Message Passing）

### 1. 基本概念

#### Mach
- **微内核操作系统**
- **macOS的基础**

#### 通信方式
- **Mach通信基于消息**
- **甚至系统调用也是消息**
- **每个任务在创建时获得两个端口**：
  - **内核（Kernel）**
  - **通知（Notify）**

### 2. Mach消息传递操作

#### ① 发送和接收消息

```c
mach_msg();
```

- **使用mach_msg()函数发送和接收消息**
- **统一的接口**

#### ② 创建端口

```c
mach_port_allocate();
```

- **通信需要端口**
- **通过mach_port_allocate()创建**

### 3. 灵活性

#### 发送和接收是灵活的

**如果邮箱满了，有四个选项**：

**① 无限期等待（Wait Indefinitely）**
- 一直等待直到有空间

**② 最多等待n毫秒（Wait at Most n Milliseconds）**
- 等待指定时间，超时返回

**③ 立即返回（Return Immediately）**
- 不等待，立即返回

**④ 临时缓存消息（Temporarily Cache a Message）**
- 暂时缓存消息，稍后发送

### 4. Mach消息结构

```c
#include <mach/mach.h>

struct message {
    mach_msg_header_t header;
    int data;
};

mach_port_t client;
mach_port_t server;
```

### 5. Mach服务器示例

```c
#include <mach/mach.h>

struct message {
    mach_msg_header_t header;
    int data;
};

int main() {
    mach_port_t server_port;
    struct message msg;
    
    // 创建端口
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &server_port);
    
    // 接收消息
    mach_msg(&msg.header, MACH_RCV_MSG, 0, sizeof(msg), server_port, 
             MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    
    // 处理消息
    printf("Server received: %d\n", msg.data);
    
    return 0;
}
```

### 6. Mach客户端示例

```c
#include <mach/mach.h>

struct message {
    mach_msg_header_t header;
    int data;
};

int main() {
    mach_port_t server_port;
    struct message msg;
    
    // 获取服务器端口
    // ... 获取端口的代码 ...
    
    // 准备消息
    msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
    msg.header.msgh_size = sizeof(msg);
    msg.header.msgh_remote_port = server_port;
    msg.header.msgh_local_port = MACH_PORT_NULL;
    msg.data = 42;
    
    // 发送消息
    mach_msg(&msg.header, MACH_SEND_MSG, sizeof(msg), 0, MACH_PORT_NULL,
             MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    
    return 0;
}
```

---

## Windows本地过程调用（Windows LPC）

### 1. 基本概念

#### LPC（Local Procedure Call）
- **Windows的消息传递中心**
- **通过高级本地过程调用（LPC）设施**
- **只在同一系统上的进程之间工作**

#### 特点
- **使用端口（类似邮箱）**建立和维护通信通道
- **类似Mach的消息传递**

### 2. 通信过程

#### 步骤

**① 客户端打开句柄**
- **客户端打开子系统连接端口对象的句柄**

**② 客户端发送连接请求**
- **客户端发送连接请求**

**③ 服务器创建端口**
- **服务器创建两个私有通信端口**
- **将其中一个的句柄返回给客户端**

**④ 通信**
- **客户端和服务器使用相应的端口句柄**：
  - **发送消息或回调**
  - **监听回复**

### 3. Windows LPC示意图

```
客户端进程
   ↓
打开连接端口句柄
   ↓
发送连接请求
   ↓
服务器进程
   ↓
创建两个私有端口
   ↓
返回一个端口句柄给客户端
   ↓
客户端和服务器使用端口通信
```

### 4. 特点

#### 优势
- **高效**：同一系统内通信
- **安全**：端口提供访问控制
- **灵活**：支持多种通信模式

#### 限制
- **只在同一系统上工作**
- **不能跨网络**

---

## 管道（Pipes）

### 1. 什么是管道？

#### 定义
- **作为管道，允许两个进程通信**
- **类似Unix的管道概念**

#### 问题

**① 通信是单向的还是双向的？**
- 只能一个方向还是两个方向？

**② 如果是双向通信，是半双工还是全双工？**
- **半双工（Half-duplex）**：一次只能一个方向
- **全双工（Full-duplex）**：可以同时双向

**③ 通信进程之间必须存在关系吗？**
- 例如：父进程-子进程关系

**④ 管道可以在网络上使用吗？**
- 本地还是网络？

### 2. 普通管道（Ordinary Pipes）

#### 定义
- **不能从创建它的进程外部访问**
- **通常，父进程创建管道**，用于与它创建的子进程通信
- **Windows称这些为匿名管道（Anonymous Pipes）**

#### 特点

**① 生产者-消费者风格**
- **生产者写入一端**（管道的写入端）
- **消费者从另一端读取**（管道的读取端）

**② 单向**
- **普通管道因此是单向的**
- **数据只能一个方向流动**

**③ 需要父-子关系**
- **通信进程之间需要父-子关系**

### 3. 普通管道示例

#### Unix/Linux

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    char buffer[100];
    
    // 创建管道
    pipe(pipefd);
    
    if (fork() == 0) {
        // 子进程：写入
        close(pipefd[0]);  // 关闭读取端
        write(pipefd[1], "Hello from child", 17);
        close(pipefd[1]);
    } else {
        // 父进程：读取
        close(pipefd[1]);  // 关闭写入端
        read(pipefd[0], buffer, 100);
        printf("Parent received: %s\n", buffer);
        close(pipefd[0]);
        wait(NULL);
    }
    
    return 0;
}
```

### 4. 命名管道（Named Pipes）

#### 定义
- **命名管道比普通管道更强大**
- **通信是双向的**
- **通信进程之间不需要父-子关系**
- **多个进程可以使用命名管道进行通信**
- **在UNIX和Windows系统上都提供**

#### 特点

**① 双向通信**
- **可以同时读写**

**② 无父子关系要求**
- **任何进程都可以使用命名管道**

**③ 多个进程**
- **多个进程可以共享命名管道**

### 5. 命名管道示例

#### Unix/Linux（FIFO）

```c
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    // 创建命名管道（FIFO）
    mkfifo("myfifo", 0666);
    
    if (fork() == 0) {
        // 子进程：写入
        int fd = open("myfifo", O_WRONLY);
        write(fd, "Hello from child", 17);
        close(fd);
    } else {
        // 父进程：读取
        int fd = open("myfifo", O_RDONLY);
        char buffer[100];
        read(fd, buffer, 100);
        printf("Parent received: %s\n", buffer);
        close(fd);
        unlink("myfifo");  // 删除FIFO
        wait(NULL);
    }
    
    return 0;
}
```

### 6. 普通管道 vs 命名管道

| 特性 | 普通管道 | 命名管道 |
|------|---------|---------|
| **方向** | 单向 | 双向 |
| **关系** | 需要父-子关系 | 不需要 |
| **多个进程** | 通常两个 | 可以多个 |
| **持久性** | 临时 | 可以持久 |
| **访问** | 只能创建者访问 | 任何进程可以访问 |

---

## 套接字（Sockets）

### 1. 什么是套接字？

#### 定义
- **套接字定义为通信的端点**
- **IP地址和端口的连接**
- **包含在消息包开头的数字**，用于区分主机上的网络服务

#### 格式
- **套接字 161.25.19.8:1625** 指主机161.25.19.8上的端口1625
- **通信在一对套接字之间进行**

### 2. 端口（Ports）

#### 知名端口（Well-Known Ports）
- **所有低于1024的端口都是知名的**
- **用于标准服务**
- **例子**：
  - **80**：HTTP
  - **443**：HTTPS
  - **22**：SSH
  - **21**：FTP

#### 回环地址（Loopback）
- **特殊IP地址127.0.0.1**（回环）
- **指运行进程的系统本身**
- **用于本地通信**

### 3. 套接字通信示意图

```
客户端                    服务器
  │                        │
  │  1. 创建套接字          │  1. 创建套接字
  │  2. 绑定地址            │  2. 绑定地址和端口
  │  3. 连接到服务器        │  3. 监听连接
  │──────────────────────→│  4. 接受连接
  │                        │  5. 接收数据
  │  4. 发送数据            │  6. 发送响应
  │──────────────────────→│
  │                        │
  │  5. 接收响应            │
  │←──────────────────────│
  │                        │
  │  6. 关闭套接字          │  7. 关闭套接字
```

### 4. Java中的套接字

#### 三种类型的套接字

**① 面向连接（Connection-Oriented）**
- **TCP（Transmission Control Protocol）**
- **可靠传输**

**② 无连接（Connectionless）**
- **UDP（User Datagram Protocol）**
- **快速但不保证可靠**

**③ 多播套接字（MulticastSocket）**
- **数据可以发送给多个接收者**

### 5. Java日期服务器示例

#### 服务器端

```java
import java.net.*;
import java.io.*;
import java.util.Date;

public class DateServer {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(6013);
            
            while (true) {
                Socket client = serverSocket.accept();
                
                PrintWriter pout = new PrintWriter(client.getOutputStream(), true);
                pout.println(new Date().toString());
                
                client.close();
            }
        } catch (IOException ioe) {
            System.err.println(ioe);
        }
    }
}
```

#### 客户端

```java
import java.net.*;
import java.io.*;

public class DateClient {
    public static void main(String[] args) {
        try {
            Socket sock = new Socket("127.0.0.1", 6013);
            
            InputStream in = sock.getInputStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            
            String line;
            while ((line = bin.readLine()) != null) {
                System.out.println(line);
            }
            
            sock.close();
        } catch (IOException ioe) {
            System.err.println(ioe);
        }
    }
}
```

---

## 远程过程调用（Remote Procedure Call, RPC）

### 1. 什么是RPC？

#### 定义
- **远程过程调用（RPC）抽象网络系统上进程之间的过程调用**
- **再次使用端口进行服务区分**
- **让远程调用看起来像本地调用**

#### 类比理解
想象RPC是远程服务：
- **本地调用** = 直接打电话给同事
- **RPC** = 通过电话会议系统打电话给远程同事
- **看起来一样**，但实际上是通过网络

### 2. RPC的工作原理

#### ① 存根（Stubs）

**客户端存根（Client-Side Stub）**
- **服务器上实际过程的客户端代理**
- **客户端存根定位服务器并整理参数（Marshalls Parameters）**

**服务器存根（Server-Side Stub）**
- **接收消息**
- **解包整理的参数（Unpacks Marshalled Parameters）**
- **在服务器上执行过程**

#### ② 参数整理（Parameter Marshalling）
- **将参数转换为网络格式**
- **处理不同架构的差异**

### 3. 数据表示

#### 外部数据表示（External Data Representation, XDR）
- **通过XDR格式处理数据表示**
- **考虑不同架构**

#### 字节序（Endianness）

**大端（Big-endian）**
- **高位字节在前**
- **例子**：某些处理器

**小端（Little-endian）**
- **低位字节在前**
- **例子**：x86处理器

**RPC处理这些差异**

### 4. 远程通信的挑战

#### 失败场景
- **远程通信比本地通信有更多失败场景**
- **消息可能丢失、重复、延迟**

#### 消息传递保证
- **消息可以恰好传递一次**，而不是最多一次
- **操作系统通常提供会合（或匹配器）服务**来连接客户端和服务器

### 5. RPC执行流程

```
客户端程序
   ↓
调用本地函数（看起来像本地调用）
   ↓
客户端存根
   ↓
整理参数
   ↓
通过网络发送
   ↓
服务器存根
   ↓
解包参数
   ↓
调用实际函数
   ↓
执行函数
   ↓
返回结果
   ↓
整理返回值
   ↓
通过网络发送
   ↓
客户端存根
   ↓
解包返回值
   ↓
返回给客户端程序
```

### 6. Windows中的RPC

#### MIDL（Microsoft Interface Definition Language）
- **存根代码从MIDL编写的规范编译**
- **定义接口和数据类型**

---

## 竞争条件（Race Condition）

### 1. 什么是竞争条件？

#### 定义
- **当多个进程访问和操作共享数据时**
- **最终结果取决于进程执行的特定顺序**
- **可能导致不正确的结果**

#### 类比理解
想象两个人同时修改同一个文档：
- **进程A和B** = 两个人
- **共享数据** = 同一个文档
- **竞争条件** = 如果不同时修改，结果可能错误

### 2. 竞争条件的例子

#### 场景
- **生产者-消费者问题**
- **使用计数器跟踪满缓冲区的数量**

#### 代码

**生产者**：
```c
while (true) {
    /* produce an item in next_produced */
    while (counter == BUFFER_SIZE)
        ; /* do nothing */
    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
    counter++;
}
```

**消费者**：
```c
while (true) {
    while (counter == 0)
        ; /* do nothing */
    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    counter--;
    /* consume the item in next_consumed */
}
```

### 3. 竞争条件分析

#### counter++的实现

```assembly
register1 = counter
register1 = register1 + 1
counter = register1
```

#### counter--的实现

```assembly
register2 = counter
register2 = register2 - 1
counter = register2
```

#### 问题执行序列

假设**counter = 5**初始值：

```
S0: 生产者执行 register1 = counter        {register1 = 5}
S1: 生产者执行 register1 = register1 + 1  {register1 = 6}
S2: 消费者执行 register2 = counter        {register2 = 5}
S3: 消费者执行 register2 = register2 - 1  {register2 = 4}
S4: 生产者执行 counter = register1        {counter = 6}
S5: 消费者执行 counter = register2        {counter = 4}
```

#### 问题
- **最终counter = 4**
- **但应该是5**（生产者+1，消费者-1）
- **丢失了一次更新！**

### 4. 为什么第一个解决方案没有竞争条件？

#### 第一个解决方案
- **最多可以填充N-1个缓冲区**
- **使用in和out指针**
- **不依赖计数器**

#### 原因
- **in和out的更新是原子的**
- **或者通过缓冲区状态隐式同步**
- **避免了竞争条件**

### 5. 如何避免竞争条件？

#### 解决方案
- **同步机制**（将在第6、7章详细讨论）
- **互斥锁（Mutex）**
- **信号量（Semaphore）**
- **确保原子操作**

---

## 客户端-服务器系统中的通信

### 1. 两种主要方法

#### ① 套接字（Sockets）
- **我们已经讨论过**
- **低级别的网络通信**

#### ② 远程过程调用（RPC）
- **我们已经讨论过**
- **高级别的抽象**

### 2. 选择

#### 何时使用套接字？
- **需要低级别控制**
- **自定义协议**
- **实时通信**

#### 何时使用RPC？
- **需要高级抽象**
- **类似本地函数调用**
- **简化开发**

---

## 总结

### 关键概念回顾

1. **消息传递（Message Passing）**：
   - 直接通信和间接通信
   - 同步和异步
   - 缓冲

2. **IPC系统示例**：
   - POSIX共享内存
   - Mach消息传递
   - Windows LPC

3. **管道（Pipes）**：
   - 普通管道和命名管道
   - 单向和双向通信

4. **套接字（Sockets）**：
   - 网络通信端点
   - TCP和UDP

5. **远程过程调用（RPC）**：
   - 远程调用的抽象
   - 存根和参数整理

6. **竞争条件（Race Condition）**：
   - 多进程访问共享数据的问题
   - 需要同步机制

### 学习要点

#### 必须理解的概念

1. **直接通信 vs 间接通信**：
   - 直接：进程明确命名彼此
   - 间接：通过邮箱通信

2. **同步 vs 异步**：
   - 阻塞 vs 非阻塞操作
   - 会合的概念

3. **缓冲类型**：
   - 零容量、有界容量、无界容量

4. **不同IPC机制**：
   - 共享内存、消息传递、管道、套接字、RPC

5. **竞争条件**：
   - 为什么发生
   - 如何避免

### 实际应用

- **理解进程间通信**：进程如何协作
- **选择合适的IPC机制**：根据需求选择
- **理解网络通信**：套接字和RPC的使用
- **避免竞争条件**：使用同步机制
- **理解现代系统**：不同操作系统的IPC实现

### 思考题

1. **直接通信和间接通信的区别是什么？**
   - 直接：进程明确命名彼此
   - 间接：通过邮箱，更灵活

2. **阻塞和非阻塞操作的区别是什么？**
   - 阻塞：等待操作完成
   - 非阻塞：立即返回

3. **为什么需要缓冲？**
   - 处理速度不匹配
   - 提高系统效率

4. **套接字和RPC的区别是什么？**
   - 套接字：低级别网络通信
   - RPC：高级别抽象

5. **什么是竞争条件？如何避免？**
   - 多进程访问共享数据导致的问题
   - 使用同步机制避免

---

*希望这个详细讲解能帮助你更好地理解进程间通信的各种机制！如果有任何不清楚的地方，可以随时提问。*

