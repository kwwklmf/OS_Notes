# 第10章：虚拟内存（第一部分）- 详细讲解

## 目录
1. [虚拟内存背景（Virtual Memory Background）](#虚拟内存背景)
2. [需求分页（Demand Paging）](#需求分页)
3. [有效-无效位（Valid-Invalid Bit）](#有效-无效位)
4. [页错误处理（Page Fault Handling）](#页错误处理)
5. [指令重启（Instruction Restart）](#指令重启)
6. [空闲帧列表（Free-Frame List）](#空闲帧列表)
7. [需求分页的阶段（Stages in Demand Paging）](#需求分页的阶段)
8. [需求分页的性能（Performance of Demand Paging）](#需求分页的性能)
9. [需求分页优化（Demand Paging Optimizations）](#需求分页优化)
10. [写时复制（Copy-on-Write, COW）](#写时复制)
11. [虚拟地址空间（Virtual Address Space）](#虚拟地址空间)
12. [共享库（Shared Libraries）](#共享库)

---

## 虚拟内存背景（Virtual Memory Background）

### 1. 为什么需要虚拟内存？

#### 问题
- **代码需要在内存中才能执行，但整个程序很少被使用**
- **错误代码、不寻常的例程、大型数据结构**
- **整个程序代码不需要同时存在**

#### 解决方案
- **考虑执行部分加载程序的能力**
- **程序不再受物理内存限制的约束**
- **每个程序运行时占用更少内存 -> 更多程序同时运行**
- **CPU利用率和吞吐量增加，响应时间或周转时间不增加**
- **加载或交换程序到内存所需的I/O更少 -> 每个用户程序运行更快**

### 2. 虚拟内存的定义

#### 基本概念
- **虚拟内存（Virtual Memory）**：用户逻辑内存与物理内存的分离
- **只有部分程序需要在内存中执行**
- **逻辑地址空间因此可以比物理地址空间大得多**

#### 优势

**① 地址空间共享**
- **允许地址空间被多个进程共享**

**② 高效的进程创建**
- **允许更高效的进程创建**

**③ 更多并发程序**
- **更多程序同时运行**

**④ 减少I/O**
- **加载或交换进程所需的I/O更少**

### 3. 虚拟地址空间

#### 定义
- **虚拟地址空间（Virtual Address Space）**：进程在内存中存储方式的逻辑视图
- **通常从地址0开始，连续地址直到空间结束**
- **同时，物理内存组织在页帧中**
- **MMU必须将逻辑映射到物理**

### 4. 虚拟内存的实现方式

#### 两种主要方法

**① 需求分页（Demand Paging）**
- **按需加载页**
- **最常用的方法**

**② 需求分段（Demand Segmentation）**
- **按需加载段**
- **较少使用**

---

## 需求分页（Demand Paging）

### 1. 需求分页的基本概念

#### 两种加载方式

**① 加载时加载整个进程**
- **在加载时将整个进程带入内存**
- **传统方法**

**② 需求分页**
- **只有在需要时才将页带入内存**
- **更高效的方法**

#### 需求分页的优势

**① 减少I/O**
- **需要的I/O更少，没有不必要的I/O**

**② 减少内存需求**
- **需要的内存更少**

**③ 更快响应**
- **响应更快**

**④ 更多用户**
- **更多用户**

### 2. 需求分页的工作原理

#### 类似带交换的分页系统
- **类似于带交换的分页系统**（右侧图表）
- **页被需要 -> 引用它**
- **无效引用 -> 中止**
- **不在内存中 -> 带入内存**

#### 延迟交换器（Lazy Swapper）
- **延迟交换器 - 除非页将被需要，否则永远不会将页交换到内存中**
- **处理页的交换器是分页器（Pager）**

### 3. 需求分页的基本概念

#### 与交换的对比
- **使用交换，分页器猜测哪些页将在再次交换出之前被使用**
- **相反，分页器只将那些页带入内存**
- **如何确定那组页？**

#### 需要新的MMU功能
- **需要新的MMU功能来实现需求分页**

#### 两种情况

**① 需要的页已经在内存中**
- **与非需求分页没有区别**

**② 需要的页不在内存中**
- **需要检测并从存储中加载页到内存**
- **不改变程序行为**
- **程序员不需要更改代码**

---

## 有效-无效位（Valid-Invalid Bit）

### 1. 有效-无效位的定义

#### 基本概念
- **每个页表项关联一个有效-无效位（Valid-Invalid Bit）**
- **v => 在内存中 - 内存驻留（In-Memory - Memory Resident）**
- **i => 不在内存中（Not-In-Memory）**

#### 初始状态
- **最初，所有项上的有效-无效位设置为i**

### 2. 页表快照示例

#### 页表状态
- **一些页在内存中（v）**
- **一些页不在内存中（i）**

#### MMU地址转换
- **在MMU地址转换期间，如果页表项中的有效-无效位是i => 页错误（Page Fault）**

### 3. 有效-无效位的作用

#### ① 指示页状态
- **指示页是否在内存中**

#### ② 触发页错误
- **如果页不在内存中，触发页错误**

#### ③ 内存保护
- **防止访问无效页**

---

## 页错误处理（Page Fault Handling）

### 1. 页错误处理的步骤

#### 步骤1：检测页错误
- **如果对页有引用，对该页的第一次引用将陷阱到操作系统**
- **页错误（Page Fault）**

#### 步骤2：操作系统检查
- **操作系统查看另一个表来决定**：
  - **无效引用 => 中止**
  - **只是不在内存中 => 继续处理**

#### 步骤3：找到空闲帧
- **找到空闲帧（Free Frame）**

#### 步骤4：交换页到帧
- **通过调度的磁盘操作将页交换到帧**

#### 步骤5：重置表
- **重置表以指示页现在在内存中**
- **设置验证位 = v**

#### 步骤6：重启指令
- **重启导致页错误的指令**

### 2. 页错误处理的详细流程

#### 完整过程
1. **陷阱到操作系统**
2. **保存用户寄存器和进程状态**
3. **确定中断是页错误**
4. **检查页引用是否合法，并确定页在磁盘上的位置**
5. **从磁盘发出读取到空闲帧**
6. **在队列中等待此设备，直到读取请求被服务**
7. **等待设备寻道和/或延迟时间**
8. **开始将页传输到空闲帧**
9. **等待时，将CPU分配给其他用户**
10. **从磁盘I/O子系统接收中断（I/O完成）**
11. **保存其他用户的寄存器和进程状态**
12. **确定中断来自磁盘**
13. **更新页表和其他表以显示页现在在内存中**
14. **等待CPU再次分配给此进程**
15. **恢复用户寄存器、进程状态和新页表，然后恢复中断的指令**

### 3. 需求分页的极端情况

#### 纯需求分页
- **极端情况 - 启动进程时内存中没有页**
- **操作系统将指令指针设置为进程的第一条指令，非内存驻留 -> 页错误**
- **对于每个其他进程页，在第一次访问时**
- **纯需求分页（Pure Demand Paging）**

#### 多条页错误
- **实际上，给定指令可能访问多个页 -> 多个页错误**
- **考虑获取和解码指令，该指令从内存中添加2个数字并将结果存储回内存**

#### 局部性原理的帮助
- **由于引用局部性（Locality of Reference），痛苦减少**

### 4. 需求分页所需的硬件支持

#### 需要的支持
- **带有效/无效位的页表**
- **辅助内存（交换设备，带交换空间）**
- **指令重启（Instruction Restart）**

---

## 指令重启（Instruction Restart）

### 1. 指令重启的问题

#### 复杂指令
- **考虑可能访问多个不同位置的指令**
- **块移动（Block Move）**
- **自动递增/递减位置**

#### 重启整个操作
- **重启整个操作**

### 2. 重叠问题

#### 问题
- **如果源和目标重叠怎么办？**

#### 解决方案
- **需要特殊处理**
- **确保数据一致性**
- **可能需要临时缓冲区**

---

## 空闲帧列表（Free-Frame List）

### 1. 空闲帧列表的定义

#### 基本概念
- **当发生页错误时，操作系统必须从辅助存储将所需页带入主内存**
- **大多数操作系统维护一个空闲帧列表（Free-Frame List）**
- **一个空闲帧池，用于满足此类请求**

### 2. 零填充按需（Zero-Fill-on-Demand）

#### 技术
- **操作系统通常使用称为零填充按需（Zero-Fill-on-Demand）的技术分配空闲帧**
- **帧的内容在分配之前被清零**

#### 原因
- **防止数据泄露**
- **确保新页从零开始**
- **安全性考虑**

### 3. 系统启动时的空闲帧列表

#### 初始化
- **当系统启动时，所有可用内存都放在空闲帧列表上**
- **系统运行过程中，释放的帧也会加入空闲帧列表**

---

## 需求分页的阶段（Stages in Demand Paging）

### 1. 需求分页的完整阶段

#### 阶段1：陷阱和保存
- **陷阱到操作系统**
- **保存用户寄存器和进程状态**

#### 阶段2：确定中断类型
- **确定中断是页错误**

#### 阶段3：检查合法性
- **检查页引用是否合法**
- **确定页在磁盘上的位置**

#### 阶段4：发出磁盘读取
- **从磁盘发出读取到空闲帧**

#### 阶段5：等待I/O
- **在队列中等待此设备，直到读取请求被服务**
- **等待设备寻道和/或延迟时间**
- **开始将页传输到空闲帧**

#### 阶段6：CPU调度
- **等待时，将CPU分配给其他用户**

#### 阶段7：I/O完成
- **从磁盘I/O子系统接收中断（I/O完成）**
- **保存其他用户的寄存器和进程状态**
- **确定中断来自磁盘**

#### 阶段8：更新表
- **更新页表和其他表以显示页现在在内存中**

#### 阶段9：恢复执行
- **等待CPU再次分配给此进程**
- **恢复用户寄存器、进程状态和新页表**
- **恢复中断的指令**

---

## 需求分页的性能（Performance of Demand Paging）

### 1. 需求分页的三个主要活动

#### ① 服务中断
- **服务中断 - 仔细编码意味着只需要几百条指令**

#### ② 读取页
- **读取页 - 大量时间**

#### ③ 重启进程
- **重启进程 - 再次只需要少量时间**

### 2. 页错误率（Page Fault Rate）

#### 定义
- **页错误率（Page Fault Rate）**：0 ≤ p ≤ 1
- **如果p = 0，没有页错误**
- **如果p = 1，每次引用都是错误**

### 3. 有效访问时间（Effective Access Time, EAT）

#### 公式

```
EAT = (1 - p) × 内存访问时间 + p × (页错误开销 + 交换页出 + 交换页入)
```

其中：
- **p**：页错误率
- **内存访问时间**：正常内存访问时间
- **页错误开销**：处理页错误的时间
- **交换页出**：将页交换出内存的时间
- **交换页入**：将页交换入内存的时间

### 4. 需求分页性能示例

#### 场景
- **内存访问时间 = 200纳秒**
- **平均页错误服务时间 = 8毫秒**

#### 计算

```
EAT = (1 - p) × 200 + p × 8,000,000
   = 200 + p × 7,999,800
```

#### 例子1：1000次访问中有1次页错误

```
p = 1/1000 = 0.001
EAT = 200 + 0.001 × 7,999,800
   = 200 + 7,999.8
   = 8,199.8 纳秒
   = 8.2 微秒
```

**结果**：**这是40倍的减慢！**

#### 例子2：性能下降 < 10%

**要求**：
```
220 > 200 + 7,999,800 × p
20 > 7,999,800 × p
p < 0.0000025
```

**结果**：**每400,000次内存访问中少于1次页错误**

### 5. 性能分析

#### 关键观察
- **页错误非常昂贵**
- **即使是很低的页错误率也会显著影响性能**
- **需要保持页错误率非常低**

---

## 需求分页优化（Demand Paging Optimizations）

### 1. 交换空间（Swap Space）

#### 交换空间vs文件系统
- **交换空间I/O比文件系统I/O快，即使在同一设备上**
- **交换以更大的块分配，比文件系统需要更少的管理**

#### 策略1：BSD Unix（旧版）
- **在进程加载时将整个进程映像复制到交换空间**
- **然后从交换空间分页进出**
- **用于旧版BSD Unix**

#### 策略2：Solaris和当前BSD
- **从磁盘上的程序二进制文件需求分页，但在释放帧时丢弃而不是分页出**
- **用于Solaris和当前BSD**

#### 仍然需要写入交换空间
- **仍然需要写入交换空间**：
  - **与文件无关的页**（如栈和堆）- **匿名内存（Anonymous Memory）**
  - **在内存中修改但尚未写回文件系统的页**

### 2. 移动系统

#### 特点
- **移动系统通常不支持交换**
- **相反，从文件系统需求分页并回收只读页**

#### 原因
- **闪存写入周期有限**
- **交换会消耗闪存寿命**

---

## 写时复制（Copy-on-Write, COW）

### 1. 写时复制的基本概念

#### 定义
- **写时复制（Copy-on-Write, COW）允许父进程和子进程最初在内存中共享相同的页**
- **如果任一进程修改共享页，只有那时才复制页**

#### 优势
- **COW允许更高效的进程创建，因为只复制修改的页**

### 2. 零填充按需页池

#### 一般情况
- **一般来说，空闲页从零填充按需页池分配**
- **池应该始终有空闲帧用于快速需求分页执行**
- **不想在页错误时释放帧以及其他处理**

#### 为什么清零页？
- **为什么在分配之前清零页？**
- **防止数据泄露**
- **安全性考虑**

### 3. vfork()系统调用

#### 定义
- **vfork()是fork()系统调用的变体**
- **父进程挂起，子进程使用父进程的写时复制地址空间**
- **设计为让子进程调用exec()**

#### 效率
- **非常高效**
- **避免不必要的复制**

### 4. 写时复制的工作流程

#### 初始状态
- **父进程和子进程共享相同的页**
- **页标记为只读**

#### 修改时
- **当进程1修改页C时**
- **检测到写操作**
- **创建页的副本**
- **更新页表**
- **允许写操作继续**

#### 优势
- **节省内存**
- **快速进程创建**
- **只复制需要的页**

---

## 虚拟地址空间（Virtual Address Space）

### 1. 虚拟地址空间的设计

#### 栈和堆的布局
- **通常设计逻辑地址空间，栈从最大逻辑地址开始并向下增长**
- **而堆向上增长**
- **最大化地址空间使用**

#### 未使用的地址空间
- **两者之间的未使用地址空间是孔（Hole）**
- **直到堆或栈增长到给定的新页，才需要物理内存**

#### 稀疏地址空间
- **启用稀疏地址空间，留下孔用于增长、动态链接库等**

### 2. 系统库共享

#### 映射到虚拟地址空间
- **系统库通过映射到虚拟地址空间共享**
- **多个进程可以共享相同的库代码**

### 3. 共享内存

#### 映射页
- **通过将页映射为读写到虚拟地址空间来共享内存**
- **多个进程可以访问相同的内存区域**

### 4. fork()时的页共享

#### 进程创建加速
- **页可以在fork()期间共享，加速进程创建**
- **使用写时复制机制**

---

## 共享库（Shared Libraries）

### 1. 共享库的概念

#### 定义
- **共享库（Shared Libraries）使用虚拟内存**
- **多个进程可以共享相同的库代码**
- **节省内存空间**

### 2. 共享库的优势

#### ① 内存效率
- **多个进程共享同一库代码**
- **不需要每个进程都有库的副本**

#### ② 一致性
- **所有进程使用相同的库版本**
- **更新库时，所有进程自动使用新版本**

#### ③ 快速加载
- **库代码已经在内存中**
- **新进程可以快速使用**

### 3. 共享库的实现

#### 虚拟内存映射
- **库代码映射到每个进程的虚拟地址空间**
- **但物理内存中只有一份副本**
- **多个进程的页表项指向相同的物理帧**

---

## 总结

### 关键概念回顾

1. **虚拟内存**：
   - 用户逻辑内存与物理内存的分离
   - 允许逻辑地址空间大于物理地址空间
   - 实现方式：需求分页、需求分段

2. **需求分页**：
   - 只有在需要时才将页带入内存
   - 减少I/O和内存需求
   - 更快响应，更多用户

3. **有效-无效位**：
   - 指示页是否在内存中
   - 触发页错误

4. **页错误处理**：
   - 检测页错误
   - 从磁盘加载页
   - 更新页表
   - 重启指令

5. **指令重启**：
   - 复杂指令可能需要重启
   - 处理重叠问题

6. **空闲帧列表**：
   - 维护空闲帧池
   - 零填充按需分配

7. **需求分页性能**：
   - 页错误率对性能影响很大
   - EAT公式
   - 需要保持低页错误率

8. **需求分页优化**：
   - 交换空间优化
   - 移动系统的特殊处理

9. **写时复制**：
   - 父进程和子进程共享页
   - 修改时才复制
   - 高效的进程创建

10. **虚拟地址空间**：
    - 栈和堆的布局
    - 稀疏地址空间
    - 系统库和共享内存

11. **共享库**：
    - 多个进程共享库代码
    - 内存效率
    - 虚拟内存映射

### 学习要点

#### 必须理解的概念

1. **虚拟内存的概念**：
   - 为什么需要虚拟内存
   - 虚拟内存如何工作

2. **需求分页**：
   - 需求分页的工作原理
   - 页错误处理过程

3. **性能分析**：
   - 页错误率对性能的影响
   - 如何计算有效访问时间

4. **写时复制**：
   - COW如何工作
   - 为什么高效

5. **虚拟地址空间**：
   - 地址空间布局
   - 共享内存和库

### 实际应用

- **理解现代内存管理**：虚拟内存是现代操作系统的基础
- **理解性能优化**：如何减少页错误率
- **理解进程创建**：写时复制如何加速进程创建
- **理解共享内存**：如何实现进程间共享
- **理解系统库**：共享库如何工作

### 思考题

1. **为什么需要虚拟内存？**
   - 允许逻辑地址空间大于物理地址空间
   - 更多程序同时运行
   - 减少I/O

2. **需求分页如何工作？**
   - 按需加载页
   - 页错误时从磁盘加载

3. **页错误率如何影响性能？**
   - 即使很低的页错误率也会显著影响性能
   - 需要保持非常低的页错误率

4. **写时复制如何提高效率？**
   - 父进程和子进程共享页
   - 只复制修改的页

5. **虚拟地址空间如何支持共享？**
   - 多个进程可以映射到相同的物理帧
   - 共享库和共享内存

---

*希望这个详细讲解能帮助你更好地理解虚拟内存的第一部分内容！如果有任何不清楚的地方，可以随时提问。*

