# 第5章：CPU调度（第三部分）- 详细讲解

## 目录
1. [Linux调度（Linux Scheduling）](#linux调度)
2. [Windows调度（Windows Scheduling）](#windows调度)
3. [Solaris调度（Solaris Scheduling）](#solaris调度)
4. [比例共享调度（Proportional Share Scheduling）](#比例共享调度)
5. [算法评估（Algorithm Evaluation）](#算法评估)
6. [POSIX实时调度（POSIX Real-Time Scheduling）](#posix实时调度)

---

## Linux调度（Linux Scheduling）

### 1. Linux调度的基本特点

#### 实时调度
- **根据POSIX.1b进行实时调度**
- **实时任务有静态优先级**
- **实时加普通映射到全局优先级方案**

#### 优先级映射
- **Nice值-20映射到全局优先级100**
- **Nice值+19映射到优先级139**
- **数值越小，优先级越高**

### 2. Linux调度域（Scheduling Domain）

#### 定义
- **Linux支持负载平衡，但也支持NUMA感知**
- **调度域是一组可以相互平衡的CPU核心集合**

#### 组织方式
- **域根据它们共享的内容组织**（例如：缓存内存）
- **目标是防止线程在域之间迁移**

#### 目的
- **保持线程在同一个域内**
- **利用缓存局部性**
- **减少内存访问延迟**

### 3. Linux调度版本2.5之前

#### 特点
- **运行标准UNIX调度算法的变体**
- **版本2.5移动到恒定顺序O(1)调度时间**

#### 调度特性
- **抢占式、基于优先级**
- **两个优先级范围**：
  - **时间共享（Time-sharing）**
  - **实时（Real-time）**

#### 优先级范围
- **实时范围从0到99**
- **Nice值从100到140**
- **映射到全局优先级，数值越小表示优先级越高**

#### 时间片（Time Slice）
- **更高优先级获得更大的q（时间量）**
- **任务只要有时间片剩余就可以运行（active）**
- **如果没有时间剩余（expired），在所有其他任务使用完它们的片之前不能运行**

#### 数据结构
- **所有可运行任务在每CPU运行队列（per-CPU runqueue）数据结构中跟踪**
- **两个优先级数组（active、expired）**
- **任务按优先级索引**

#### 工作方式
- **当没有更多active时，数组交换**
- **工作良好，但对交互式进程响应时间差**

### 4. Linux调度版本2.6.23：完全公平调度器（CFS）

#### 基本概念
- **完全公平调度器（Completely Fair Scheduler, CFS）**
- **调度类（Scheduling Classes）**
- **每个类有特定优先级**
- **调度器选择最高调度类中优先级最高的任务**

#### 关键特点

**① 基于比例而非固定时间量**
- **不是基于固定时间分配的量子**
- **基于CPU时间的比例**

**② 两个调度类**
- **默认（default）**
- **实时（real-time）**
- **可以添加其他类**

#### CFS的工作原理

**① 虚拟运行时间（Virtual Run Time, vruntime）**
- **CFS调度器维护每个任务的虚拟运行时间**
- **存储在变量vruntime中**
- **与基于任务优先级的衰减因子关联**
- **低优先级 = 高衰减率**
- **正常默认优先级产生虚拟运行时间 = 实际运行时间**

**② 目标延迟（Target Latency）**
- **基于Nice值从-20到+19计算量子**
- **较低值是较高优先级**
- **计算目标延迟**：任务应该至少运行一次的间隔时间
- **如果活动任务数量增加，目标延迟可以增加**

**③ 选择下一个任务**
- **为了决定下一个要运行的任务，调度器选择虚拟运行时间最低的任务**
- **确保公平性**

#### CFS的优势

**① 公平性**
- **所有任务获得公平的CPU时间份额**
- **基于虚拟运行时间**

**② 响应性**
- **比O(1)调度器对交互式进程响应更好**
- **动态调整时间片**

**③ 可扩展性**
- **可以处理大量任务**
- **性能良好**

### 5. CFS性能

#### 特点
- **提供良好的公平性**
- **对交互式进程响应好**
- **适合桌面和服务器系统**

---

## Windows调度（Windows Scheduling）

### 1. Windows调度的基本特点

#### 调度方式
- **Windows使用基于优先级的抢占式调度**
- **最高优先级的线程运行下一个**
- **分发器（Dispatcher）是调度器**

#### 线程运行条件
- **线程运行直到**：
  1. **阻塞（blocks）**
  2. **使用时间片（uses time slice）**
  3. **被更高优先级线程抢占（preempted by higher-priority thread）**

#### 实时线程
- **实时线程可以抢占非实时线程**

### 2. Windows优先级方案

#### 32级优先级方案
- **32个优先级级别**
- **可变类（Variable Class）是1-15**
- **实时类（Real-Time Class）是16-31**
- **优先级0是内存管理线程**

#### 队列结构
- **每个优先级一个队列**
- **如果没有可运行线程，运行空闲线程（Idle Thread）**

### 3. Windows优先级类（Priority Classes）

#### Win32 API优先级类

**① REALTIME_PRIORITY_CLASS**
- **实时优先级类**
- **最高优先级**

**② HIGH_PRIORITY_CLASS**
- **高优先级类**

**③ ABOVE_NORMAL_PRIORITY_CLASS**
- **高于正常优先级类**

**④ NORMAL_PRIORITY_CLASS**
- **正常优先级类**
- **默认**

**⑤ BELOW_NORMAL_PRIORITY_CLASS**
- **低于正常优先级类**

**⑥ IDLE_PRIORITY_CLASS**
- **空闲优先级类**
- **最低优先级**

#### 特点
- **除了REALTIME，所有都是可变的（Variable）**
- **实时类是固定的**

### 4. 线程相对优先级（Thread Relative Priority）

#### 定义
- **给定优先级类内的线程有相对优先级**
- **优先级类和相对优先级组合给出数字优先级**

#### 相对优先级类型

**① TIME_CRITICAL**
- **时间关键**
- **最高**

**② HIGHEST**
- **最高**

**③ ABOVE_NORMAL**
- **高于正常**

**④ NORMAL**
- **正常**
- **默认**

**⑤ BELOW_NORMAL**
- **低于正常**

**⑥ LOWEST**
- **最低**

**⑦ IDLE**
- **空闲**
- **最低**

### 5. Windows优先级调整

#### 基础优先级
- **基础优先级是类内的NORMAL**
- **如果量子到期，优先级降低**
- **但从不低于基础**

#### 等待后的优先级提升
- **如果发生等待，优先级根据等待的内容提升**
- **前台窗口获得3倍优先级提升**

### 6. Windows用户模式调度（User-Mode Scheduling, UMS）

#### 定义
- **Windows 7添加了用户模式调度（UMS）**
- **应用程序创建和管理线程，独立于内核**
- **对于大量线程，效率更高**

#### UMS调度器
- **UMS调度器来自编程语言库**
- **例如**：C++并发运行时（Concurrent Runtime, ConcRT）框架

#### 优势
- **减少内核开销**
- **更快的线程创建和切换**
- **适合高并发应用**

---

## Solaris调度（Solaris Scheduling）

### 1. Solaris调度的基本特点

#### 基于优先级的调度
- **Solaris使用基于优先级的调度**
- **六个类可用**

### 2. Solaris调度类

#### ① 时间共享（Time Sharing, TS）
- **默认类**
- **多级反馈队列**
- **可加载表，可由系统管理员配置**

#### ② 交互式（Interactive, IA）
- **交互式进程**
- **优化响应时间**

#### ③ 实时（Real Time, RT）
- **实时任务**
- **最高优先级**

#### ④ 系统（System, SYS）
- **系统进程**
- **内核线程**

#### ⑤ 公平共享（Fair Share, FSS）
- **公平共享调度**
- **基于份额**

#### ⑥ 固定优先级（Fixed Priority, FP）
- **固定优先级**
- **优先级不变**

### 3. Solaris调度规则

#### 调度过程
- **给定线程一次只能在一个类中**
- **每个类有自己的调度算法**
- **调度器将类特定优先级转换为每线程全局优先级**
- **最高优先级的线程运行下一个**

#### 运行条件
- **运行直到**：
  1. **阻塞（blocks）**
  2. **使用时间片（uses time slice）**
  3. **被更高优先级线程抢占（preempted）**

#### 相同优先级
- **多个相同优先级的线程通过RR选择**

### 4. Solaris调度表（Dispatch Table）

#### 定义
- **可加载表**
- **可由系统管理员配置**
- **定义每个优先级的时间片**

#### 灵活性
- **可以根据系统需求调整**
- **优化性能**

---

## 比例共享调度（Proportional Share Scheduling）

### 1. 什么是比例共享调度？

#### 定义
- **T个份额（Shares）分配给系统中的所有进程**
- **应用程序接收N个份额，其中N < T**
- **这确保每个应用程序将接收总处理器时间的N/T**

#### 类比理解
想象比例共享是公司股份：
- **总股份** = T
- **你的股份** = N
- **你的收益比例** = N/T
- **你拥有的股份越多，收益比例越大**

### 2. 比例共享调度的特点

#### ① 公平性
- **每个进程获得与其份额成比例的CPU时间**
- **份额越多，CPU时间越多**

#### ② 可预测性
- **可以预测每个进程将获得多少CPU时间**
- **基于份额比例**

#### ③ 灵活性
- **可以动态调整份额**
- **适应不同需求**

### 3. 比例共享调度的例子

#### 场景
- **总份额T = 100**
- **进程A：N = 40份额**
- **进程B：N = 30份额**
- **进程C：N = 30份额**

#### CPU时间分配
- **进程A：40/100 = 40%的CPU时间**
- **进程B：30/100 = 30%的CPU时间**
- **进程C：30/100 = 30%的CPU时间**

### 4. 比例共享调度的优势

#### ① 保证最小份额
- **每个进程保证获得最小CPU时间份额**

#### ② 公平分配
- **根据份额公平分配CPU时间**

#### ③ 适合多租户系统
- **适合云计算环境**
- **可以为不同用户分配不同份额**

---

## 算法评估（Algorithm Evaluation）

### 1. 为什么需要算法评估？

#### 问题
- **如何为操作系统选择CPU调度算法？**
- **需要评估不同算法的性能**

#### 方法
- **确定准则，然后评估算法**
- **使用不同的评估方法**

### 2. 确定性建模（Deterministic Modeling）

#### 定义
- **一种分析评估类型**
- **采用特定的预定工作负载**
- **定义每个算法对该工作负载的性能**

#### 特点
- **简单快速**
- **但需要输入的精确数字**
- **仅适用于那些输入**

#### 例子

**场景**：
- **考虑5个进程在时间0到达**：
  - P1: 突发时间10
  - P2: 突发时间29
  - P3: 突发时间3
  - P4: 突发时间7
  - P5: 突发时间12

**评估结果**：

**FCFS**：
- **平均等待时间：28ms**

**非抢占式SJF**：
- **平均等待时间：13ms**

**RR（时间量=10）**：
- **平均等待时间：23ms**

**结论**：**SJF给出最小平均等待时间**

### 3. 队列模型（Queueing Models）

#### 定义
- **概率性地描述进程的到达，以及CPU和I/O突发**
- **通常是指数分布，由均值描述**
- **计算平均吞吐量、利用率、等待时间等**

#### 系统模型
- **计算机系统描述为服务器网络**
- **每个服务器有等待进程队列**
- **知道到达率和服务率**
- **计算利用率、平均队列长度、平均等待时间等**

#### 优势
- **可以处理随机输入**
- **提供统计结果**

### 4. Little公式（Little's Formula）

#### 公式

```
n = λ × W
```

其中：
- **n** = 平均队列长度
- **W** = 队列中的平均等待时间
- **λ** = 队列的平均到达率

#### Little定律
- **在稳定状态下，离开队列的进程必须等于到达的进程**
- **因此：n = λ × W**

#### 有效性
- **对任何调度算法和到达分布都有效**

#### 例子
- **如果平均每秒7个进程到达**
- **通常队列中有14个进程**
- **那么每个进程的平均等待时间 = 2秒**

**计算**：
```
n = 14
λ = 7/秒
W = n / λ = 14 / 7 = 2秒
```

### 5. 仿真（Simulations）

#### 定义
- **队列模型有限**
- **仿真更准确**
- **计算机系统的编程模型**

#### 特点
- **时钟是变量**
- **收集统计信息，指示算法性能**

#### 数据来源

**① 随机数生成器**
- **根据概率使用随机数生成器**
- **数学或经验定义的分布**

**② 跟踪磁带（Trace Tapes）**
- **记录真实系统中真实事件的序列**
- **更准确，但需要实际系统数据**

### 6. 实现（Implementation）

#### 问题
- **即使仿真也有有限的准确性**
- **只是实现新调度器并在真实系统中测试**

#### 挑战

**① 高成本、高风险**
- **实现和测试成本高**
- **可能影响系统稳定性**

**② 环境变化**
- **环境变化很大**
- **在一个环境中好，在另一个环境中可能不好**

#### 解决方案

**① 灵活调度器**
- **最灵活的调度器可以按站点或按系统修改**
- **或API修改优先级**

**② 但环境仍然变化**
- **需要持续调整**

### 7. 评估方法对比

| 方法 | 优点 | 缺点 |
|------|------|------|
| **确定性建模** | 简单快速 | 需要精确输入，仅适用于特定输入 |
| **队列模型** | 处理随机输入 | 假设可能不准确 |
| **仿真** | 更准确 | 需要数据，可能耗时 |
| **实现** | 最准确 | 高成本，高风险 |

---

## POSIX实时调度（POSIX Real-Time Scheduling）

### 1. POSIX.1b标准

#### 定义
- **POSIX.1b标准API提供管理实时线程的函数**
- **为实时线程定义两个调度类**

### 2. POSIX实时调度类

#### ① SCHED_FIFO
- **线程使用FCFS策略和FIFO队列调度**
- **没有时间片**
- **相同优先级的线程没有时间片**

#### ② SCHED_RR
- **类似于SCHED_FIFO，除了相同优先级的线程发生时间片**
- **Round Robin调度**

### 3. POSIX调度函数

#### ① 获取调度策略

```c
pthread_attr_getsched_policy(pthread_attr_t *attr, int *policy);
```

- **获取当前调度策略**

#### ② 设置调度策略

```c
pthread_attr_setsched_policy(pthread_attr_t *attr, int policy);
```

- **设置调度策略**

### 4. POSIX实时调度API示例

#### 完整示例

```c
#include <pthread.h>
#include <stdio.h>

#define NUM_THREADS 5

int main(int argc, char *argv[]) {
    int i, policy;
    pthread_t tid[NUM_THREADS];
    pthread_attr_t attr;
    
    // 获取默认属性
    pthread_attr_init(&attr);
    
    // 获取当前调度策略
    if (pthread_attr_getschedpolicy(&attr, &policy) != 0)
        fprintf(stderr, "Unable to get policy.\n");
    else {
        if (policy == SCHED_OTHER)
            printf("SCHED_OTHER\n");
        else if (policy == SCHED_RR)
            printf("SCHED_RR\n");
        else if (policy == SCHED_FIFO)
            printf("SCHED_FIFO\n");
    }
    
    // 设置调度策略 - FIFO, RR, 或OTHER
    if (pthread_attr_setschedpolicy(&attr, SCHED_FIFO) != 0)
        fprintf(stderr, "Unable to set policy.\n");
    
    // 创建线程
    for (i = 0; i < NUM_THREADS; i++)
        pthread_create(&tid[i], &attr, runner, NULL);
    
    // 等待每个线程
    for (i = 0; i < NUM_THREADS; i++)
        pthread_join(tid[i], NULL);
    
    return 0;
}

// 每个线程将在这个函数中开始控制
void *runner(void *param) {
    // 做一些工作...
    pthread_exit(0);
}
```

### 5. POSIX调度策略对比

| 策略 | 调度方式 | 时间片 | 适用场景 |
|------|---------|--------|---------|
| **SCHED_OTHER** | 默认调度 | 有 | 普通线程 |
| **SCHED_FIFO** | FIFO | 无 | 实时线程 |
| **SCHED_RR** | Round Robin | 有 | 实时线程 |

---

## 操作系统示例总结

### 1. Linux调度

#### 版本演进
- **2.5之前**：标准UNIX调度算法变体
- **2.5**：O(1)调度器
- **2.6.23**：完全公平调度器（CFS）

#### 特点
- **实时调度支持**
- **NUMA感知**
- **负载平衡**
- **调度域**

### 2. Windows调度

#### 特点
- **32级优先级方案**
- **基于优先级的抢占式调度**
- **优先级类和相对优先级**
- **用户模式调度（UMS）**

### 3. Solaris调度

#### 特点
- **六个调度类**
- **可配置调度表**
- **灵活的调度策略**

---

## 总结

### 关键概念回顾

1. **Linux调度**：
   - O(1)调度器
   - 完全公平调度器（CFS）
   - 调度域和NUMA感知

2. **Windows调度**：
   - 32级优先级方案
   - 优先级类和相对优先级
   - 用户模式调度（UMS）

3. **Solaris调度**：
   - 六个调度类
   - 可配置调度表

4. **比例共享调度**：
   - 基于份额的调度
   - 保证最小CPU时间份额

5. **算法评估**：
   - 确定性建模
   - 队列模型
   - 仿真
   - 实现

6. **POSIX实时调度**：
   - SCHED_FIFO
   - SCHED_RR
   - 调度策略API

### 学习要点

#### 必须理解的概念

1. **不同操作系统的调度实现**：
   - Linux CFS的工作原理
   - Windows优先级方案
   - Solaris调度类

2. **比例共享调度**：
   - 份额的概念
   - 如何保证公平性

3. **算法评估方法**：
   - 各种方法的优缺点
   - 何时使用哪种方法

4. **POSIX实时调度**：
   - FIFO和RR的区别
   - 如何设置调度策略

### 实际应用

- **理解现代调度器**：CFS、Windows调度器的实际应用
- **理解实时调度**：如何保证实时性
- **理解算法评估**：如何选择和评估调度算法
- **理解多系统差异**：不同操作系统的调度实现
- **理解性能优化**：如何优化调度性能

### 思考题

1. **CFS和O(1)调度器的区别是什么？**
   - CFS：基于虚拟运行时间，更公平
   - O(1)：固定时间片，更快但可能不公平

2. **Windows优先级方案如何工作？**
   - 32级优先级，优先级类和相对优先级组合

3. **比例共享调度的优势是什么？**
   - 保证最小份额，公平分配，可预测

4. **如何评估调度算法？**
   - 确定性建模、队列模型、仿真、实现

5. **SCHED_FIFO和SCHED_RR的区别是什么？**
   - SCHED_FIFO：无时间片
   - SCHED_RR：有时间片

---

*希望这个详细讲解能帮助你更好地理解CPU调度的实际实现和评估方法！如果有任何不清楚的地方，可以随时提问。*

