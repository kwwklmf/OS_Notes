# 第9章：虚拟内存（第二部分）- 详细讲解

## 目录
1. [页表结构（Structure of the Page Table）](#页表结构)
2. [分层页表（Hierarchical Page Tables）](#分层页表)
3. [哈希页表（Hashed Page Tables）](#哈希页表)
4. [倒置页表（Inverted Page Tables）](#倒置页表)
5. [Oracle SPARC Solaris](#oracle-sparc-solaris)
6. [交换（Swapping）](#交换)
7. [内存保护（Memory Protection）](#内存保护)
8. [上下文切换时间和交换（Context Switch Time and Swapping）](#上下文切换时间和交换)
9. [移动系统上的交换（Swapping on Mobile Systems）](#移动系统上的交换)
10. [Intel架构（Intel Architectures）](#intel架构)
11. [ARM架构（ARM Architecture）](#arm架构)
12. [共享页（Shared Pages）](#共享页)

---

## 页表结构（Structure of the Page Table）

### 1. 页表大小问题

#### 问题描述
- **使用直接方法，分页的内存结构可能变得巨大**
- **考虑现代计算机上的32位逻辑地址空间**
- **页大小为4 KB（2^12）**
- **页表将有100万个项（2^32 / 2^12）**
- **如果每个项是4字节 -> 每个进程仅页表就需要4 MB的物理地址空间**

#### 问题分析
- **不想在主内存中连续分配**
- **需要更高效的页表结构**

### 2. 解决方案

#### 三种主要方法

**① 分层页表（Hierarchical Paging）**
- **将页表分成更小的单元**
- **多级页表**

**② 哈希页表（Hashed Page Tables）**
- **使用哈希表存储页表项**
- **适合大地址空间**

**③ 倒置页表（Inverted Page Tables）**
- **每个物理页一个项**
- **而不是每个逻辑页一个项**

---

## 分层页表（Hierarchical Page Tables）

### 1. 两级页表（Two-Level Page Tables）

#### 基本概念
- **将逻辑地址空间分解为多个页表**
- **一个简单的技术是两级页表**
- **然后我们对页表进行分页**

#### 地址划分

**32位机器，4K页大小**：
- **逻辑地址分为**：
  - **页号：20位**
  - **页偏移：12位**

**由于页表被分页，页号进一步分为**：
  - **10位页号（p1）**：外层页表的索引
  - **10位页偏移（p2）**：内层页表页内的位移

#### 地址格式

```
逻辑地址 = [p1 (10位)] [p2 (10位)] [d (12位)]
```

其中：
- **p1**：外层页表的索引
- **p2**：内层页表页内的位移
- **d**：页偏移

#### 地址转换过程

1. **使用p1索引外层页表**
2. **从外层页表获取内层页表的基址**
3. **使用p2索引内层页表**
4. **从内层页表获取帧号**
5. **将帧号与页偏移d组合**
6. **生成物理地址**

### 2. 64位逻辑地址空间

#### 问题
- **即使是两级分页方案也不够**
- **如果页大小是4 KB（2^12）**
- **那么页表有2^52个项**

#### 两级方案的问题
- **如果两级方案，内层页表可能是2^10个4字节项**
- **地址看起来像**：
  - **外层页表有2^42个项或2^44字节**
  - **仍然太大**

#### 解决方案：三级页表

**① 添加第二层外层页表**
- **但在这个例子中，第二层外层页表仍然是2^34字节大小**
- **可能需要4次内存访问才能到达一个物理内存位置**

#### 三级分页方案

**地址划分**：
- **第一级页表索引**
- **第二级页表索引**
- **第三级页表索引**
- **页偏移**

**访问次数**：
- **最多4次内存访问**
- **一次第一级页表**
- **一次第二级页表**
- **一次第三级页表**
- **一次数据访问**

### 3. 前向映射页表（Forward-Mapped Page Table）

#### 定义
- **也称为前向映射页表**
- **从外层页表到内层页表，再到物理地址**

#### 特点
- **逻辑地址到物理地址的映射是前向的**
- **从逻辑地址开始，逐步映射到物理地址**

---

## 哈希页表（Hashed Page Tables）

### 1. 哈希页表的基本概念

#### 适用场景
- **常见于地址空间 > 32位**
- **适合大地址空间**

#### 工作原理

**① 哈希函数**
- **虚拟页号被哈希到页表**
- **这个页表包含哈希到同一位置的元素链**

**② 链式结构**
- **每个元素包含**：
  1. **虚拟页号（Virtual Page Number）**
  2. **映射页帧的值（Value of the Mapped Page Frame）**
  3. **指向下一个元素的指针（Pointer to the Next Element）**

**③ 搜索过程**
- **虚拟页号在这个链中比较，搜索匹配**
- **如果找到匹配，提取相应的物理帧**

### 2. 哈希页表的优势

#### ① 空间效率
- **不需要为所有可能的虚拟页号分配空间**
- **只为实际使用的页分配空间**

#### ② 适合稀疏地址空间
- **适合地址空间大但使用少的场景**
- **不需要存储所有页表项**

### 3. 集群页表（Clustered Page Tables）

#### 定义
- **64位地址的变体是集群页表**
- **类似于哈希，但每个项引用多个页（如16个），而不是1个**

#### 特点
- **特别适用于稀疏地址空间**
- **其中内存引用是不连续和分散的**

#### 优势
- **减少页表项数量**
- **提高空间效率**
- **适合大地址空间**

---

## 倒置页表（Inverted Page Tables）

### 1. 倒置页表的基本概念

#### 传统页表的问题
- **每个进程有一个页表**
- **跟踪所有可能的逻辑页**
- **对于大地址空间，页表可能非常大**

#### 倒置页表的思想
- **不是每个进程有一个页表并跟踪所有可能的逻辑页**
- **而是跟踪所有物理页**
- **每个真实内存页一个项**

### 2. 倒置页表的结构

#### 每个项包含
- **存储在该真实内存位置中的页的虚拟地址**
- **拥有该页的进程的信息**

#### 优势
- **减少存储每个页表所需的内存**
- **页表大小与物理内存大小相关，而不是虚拟地址空间大小**

#### 缺点
- **增加页引用发生时搜索表所需的时间**
- **需要搜索整个表来找到匹配的虚拟地址**

### 3. 哈希表优化

#### 解决方案
- **使用哈希表将搜索限制为一个 - 或最多几个 - 页表项**
- **显著减少搜索时间**

#### TLB加速
- **TLB可以加速访问**
- **缓存最近使用的转换**

### 4. 共享内存的实现

#### 问题
- **如何实现共享内存？**
- **多个进程需要映射到同一个物理地址**

#### 解决方案
- **一个虚拟地址到共享物理地址的映射**
- **多个进程的页表项可以指向同一个物理帧**

### 5. 倒置页表架构

#### 工作流程
1. **虚拟地址（虚拟页号 + 页偏移）**
2. **使用哈希函数计算索引**
3. **在哈希表中搜索匹配的虚拟页号**
4. **如果找到，获取物理帧号**
5. **将物理帧号与页偏移组合**
6. **生成物理地址**

---

## Oracle SPARC Solaris

### 1. Oracle SPARC Solaris的基本特点

#### 系统描述
- **考虑现代、64位操作系统的例子，硬件紧密集成**
- **目标是效率和低开销**
- **基于哈希，但更复杂**

### 2. 双哈希表结构

#### 两个哈希表

**① 内核哈希表**
- **一个用于内核**

**② 用户进程哈希表**
- **一个用于所有用户进程**

#### 功能
- **每个将内存地址从虚拟映射到物理内存**
- **每个项表示一个连续的映射虚拟内存区域**
- **比每个页有一个单独的哈希表项更高效**

#### 项结构
- **每个项有基址（Base Address）和跨度（Span）**
- **跨度表示该项表示的页数**

### 3. TLB和TSB

#### TLB（Translation Look-Aside Buffer）
- **TLB保存转换表项（Translation Table Entries, TTEs）用于快速硬件查找**

#### TSB（Translation Storage Buffer）
- **TTE的缓存驻留在转换存储缓冲区（TSB）中**
- **包括每个最近访问的页的项**

### 4. 地址转换过程

#### 步骤

**① TLB搜索**
- **虚拟地址引用导致TLB搜索**

**② TLB未命中处理**
- **如果未命中，硬件遍历内存中的TSB，查找与地址对应的TTE**

**③ TSB命中**
- **如果找到匹配，CPU将TSB项复制到TLB，转换完成**

**④ TSB未命中**
- **如果没有找到匹配，内核被中断以搜索哈希表**
- **内核然后从适当的哈希表创建TTE并将其存储在TSB中**
- **中断处理程序将控制返回给MMU，MMU完成地址转换**

---

## 交换（Swapping）

### 1. 交换的基本概念

#### 定义
- **一个进程可以临时从内存交换到后备存储（Backing Store）**
- **然后带回内存以继续执行**

#### 优势
- **进程的总物理内存空间可以超过物理内存**
- **允许运行比物理内存更大的程序**

### 2. 后备存储（Backing Store）

#### 要求
- **快速磁盘，足够大以容纳所有用户的所有内存映像的副本**
- **必须提供对这些内存映像的直接访问**

#### 特点
- **通常比主内存慢**
- **但容量大**
- **可以存储多个进程的内存映像**

### 3. 交换变体

#### 滚出滚入（Roll Out, Roll In）
- **交换变体用于基于优先级的调度算法**
- **较低优先级的进程被交换出，以便可以加载和执行较高优先级的进程**

### 4. 交换时间

#### 主要部分
- **交换时间的主要部分是传输时间**
- **总传输时间与交换的内存量直接成正比**

#### 系统维护
- **系统维护一个就绪队列（Ready Queue）**
- **就绪运行的进程，其内存映像在磁盘上**

### 5. 交换回相同地址？

#### 问题
- **交换出的进程是否需要交换回相同的物理地址？**

#### 答案
- **取决于地址绑定方法**
- **如果使用执行时绑定，不需要相同地址**
- **如果使用加载时绑定，可能需要相同地址**

#### 额外考虑
- **加上考虑进程内存空间的待处理I/O**
- **如果进程正在等待I/O，交换可能有问题**

### 6. 现代系统中的交换

#### 修改版本
- **许多系统上找到交换的修改版本**（例如，UNIX、Linux和Windows）

#### 交换策略
- **交换通常被禁用**
- **如果分配的内存超过阈值，则启动**
- **一旦内存需求降低到阈值以下，再次禁用**

#### 原因
- **交换很慢**
- **现代系统使用分页而不是完整进程交换**

---

## 内存保护（Memory Protection）

### 1. 内存保护的基本概念

#### 实现方式
- **内存保护通过将保护位（Protection Bit）与每个帧关联来实现**
- **指示是否允许只读或读写访问**

#### 扩展保护位
- **还可以添加更多位来指示页仅执行等**
- **例如：读、写、执行权限**

### 2. 有效-无效位（Valid-Invalid Bit）

#### 定义
- **有效-无效位附加到页表中的每个项**
- **"有效"表示关联的页在进程的逻辑地址空间中，因此是合法页**
- **"无效"表示页不在进程的逻辑地址空间中**

#### 用途
- **防止访问无效地址**
- **触发陷阱到内核**

### 3. 页表长度寄存器（PTLR）

#### 替代方案
- **或使用页表长度寄存器（Page-Table Length Register, PTLR）**
- **指示页表的大小**
- **检查页号是否在有效范围内**

### 4. 违规处理

#### 结果
- **任何违规都会导致陷阱到内核**
- **内核处理内存保护违规**
- **可能终止进程或处理错误**

---

## 上下文切换时间和交换（Context Switch Time and Swapping）

### 1. 上下文切换中的交换

#### 场景
- **如果要放在CPU上的下一个进程不在内存中**
- **需要交换出一个进程并交换入目标进程**

#### 问题
- **上下文切换时间可能非常高**

### 2. 交换时间计算

#### 例子
- **100MB进程交换到硬盘**
- **传输速率为50MB/秒**

**计算**：
- **交换出时间：2000 ms**（100MB / 50MB/s = 2秒）
- **加上相同大小进程的交换入**
- **总上下文切换交换组件时间：4000ms（4秒）**

#### 性能影响
- **上下文切换时间非常长**
- **严重影响系统性能**

### 3. 减少交换大小

#### 方法
- **如果减少交换的内存大小，可以减少**
- **通过知道实际使用了多少内存**

#### 系统调用
- **系统调用通过request_memory()和release_memory()通知OS内存使用**
- **进程可以告诉操作系统实际需要多少内存**

### 4. 交换的其他约束

#### 待处理I/O
- **待处理I/O - 不能交换出，因为I/O会发生在错误的进程上**
- **或总是将I/O传输到内核空间，然后到I/O设备**
- **称为双缓冲（Double Buffering），增加开销**

### 5. 现代操作系统中的交换

#### 标准交换
- **标准交换不在现代操作系统中使用**
- **但修改版本很常见**

#### 现代策略
- **仅在空闲内存极低时交换**
- **使用分页而不是完整进程交换**
- **更细粒度的内存管理**

---

## 移动系统上的交换（Swapping on Mobile Systems）

### 1. 移动系统的特点

#### 通常不支持
- **移动系统上通常不支持交换**

#### 原因

**① 基于闪存（Flash Memory）**
- **闪存基础**
- **少量空间**
- **写入周期有限**

**② 性能问题**
- **移动平台上闪存和CPU之间的吞吐量差**
- **交换会很慢**

### 2. 替代方法

#### iOS方法
- **iOS要求应用程序自愿释放分配的内存**
- **只读数据被丢弃，如果需要从闪存重新加载**
- **如果无法释放，可能导致终止**

#### Android方法
- **如果空闲内存低，Android终止应用程序**
- **但首先将应用程序状态写入闪存以便快速重启**
- **下次启动时更快**

### 3. 分页支持

#### 两种系统
- **两种操作系统都支持下面讨论的分页**
- **使用分页而不是完整进程交换**
- **更细粒度的内存管理**

---

## Intel架构（Intel Architectures）

### 1. Intel架构概述

#### 主导行业芯片
- **Pentium CPU是32位，称为IA-32架构**
- **当前Intel CPU是64位，称为IA-64架构**
- **芯片有很多变体，这里涵盖主要思想**

### 2. Intel IA-32架构

#### 支持的功能
- **支持分段（Segmentation）和带分页的分段**
- **每个段可以是4 GB**
- **每个进程最多16 K段**

#### 段分区
- **分为两个分区**：
  - **第一个分区最多8 K段是进程私有的**（保存在本地描述符表（Local Descriptor Table, LDT）中）
  - **第二个分区最多8K段在所有进程之间共享**（保存在全局描述符表（Global Descriptor Table, GDT）中）

#### 地址转换过程

**① 逻辑地址生成**
- **CPU生成逻辑地址**
- **选择器（Selector）给分段单元**

**② 线性地址生成**
- **分段单元产生线性地址（Linear Address）**

**③ 物理地址生成**
- **线性地址给分页单元**
- **分页单元生成主内存中的物理地址**

**④ 分页单元**
- **分页单元形成MMU的等价物**
- **页大小可以是4 KB或4 MB**

### 3. Intel IA-32页地址扩展（PAE）

#### 问题
- **32位地址限制导致Intel创建页地址扩展（Page Address Extension, PAE）**
- **允许32位应用程序访问超过4GB的内存空间**

#### 解决方案
- **分页转到3级方案**
- **前两位引用页目录指针表（Page Directory Pointer Table）**
- **页目录和页表项移动到64位大小**

#### 效果
- **净效果是将地址空间增加到36位 - 64GB的物理内存**

### 4. Intel x86-64架构

#### 当前一代
- **当前一代Intel x86架构**
- **64位是巨大的（> 16 exabytes）**

#### 实际实现
- **实际上只实现48位寻址**
- **页大小为4 KB、2 MB、1 GB**

#### 分页层次
- **四级分页层次**
- **也可以使用PAE，因此虚拟地址是48位，物理地址是52位**

---

## ARM架构（ARM Architecture）

### 1. ARM架构概述

#### 主导移动平台芯片
- **主导移动平台芯片**（例如，Apple iOS和Google Android设备）
- **现代、节能、32位CPU**

### 2. ARM分页

#### 页大小
- **4 KB和16 KB页**
- **1 MB和16 MB页（称为节（Sections））**

#### 分页级别
- **节的一级分页，较小页的两级**
- **根据页大小使用不同的分页级别**

### 3. ARM TLB层次

#### 两级TLB

**① 外层**
- **外层有两个微TLB（Micro TLBs）**
- **一个数据，一个指令**

**② 内层**
- **内层是单个主TLB**

#### TLB查找过程
1. **首先检查内层**
2. **如果未命中，检查外层**
3. **如果未命中，CPU执行页表遍历（Page Table Walk）**

#### 优势
- **分层TLB提高性能**
- **减少TLB未命中率**

---

## 共享页（Shared Pages）

### 1. 共享代码（Shared Code）

#### 基本概念
- **只读（可重入（Reentrant））代码的一个副本在进程之间共享**
- **例如：文本编辑器、编译器、窗口系统**

#### 特点
- **类似于多个线程共享同一个进程空间**
- **如果允许共享读写页，也适用于进程间通信**

### 2. 私有代码和数据（Private Code and Data）

#### 基本概念
- **每个进程保持代码和数据的单独副本**
- **私有代码和数据的页可以出现在逻辑地址空间中的任何位置**

### 3. 共享页的优势

#### ① 内存效率
- **多个进程共享同一代码**
- **节省内存空间**

#### ② 一致性
- **所有进程使用相同的代码版本**
- **更新代码时，所有进程自动使用新版本**

#### ③ 进程间通信
- **如果允许共享读写页，可以用于进程间通信**
- **多个进程可以访问同一内存区域**

### 4. 共享页的实现

#### 页表项
- **多个进程的页表项指向同一个物理帧**
- **但每个进程有自己的页表项**

#### 保护
- **共享页通常是只读的**
- **防止一个进程修改共享代码**

#### 写时复制（Copy-on-Write）
- **如果进程需要修改共享页，使用写时复制**
- **创建页的副本供进程使用**

---

## 总结

### 关键概念回顾

1. **页表结构**：
   - 分层页表：多级页表结构
   - 哈希页表：使用哈希表存储页表项
   - 倒置页表：每个物理页一个项

2. **64位地址空间**：
   - 需要多级分页方案
   - 三级或四级分页
   - 可能多次内存访问

3. **哈希页表**：
   - 适合大地址空间
   - 使用链式结构处理冲突
   - 集群页表用于稀疏地址空间

4. **倒置页表**：
   - 页表大小与物理内存相关
   - 使用哈希表优化搜索
   - 共享内存的实现

5. **Oracle SPARC Solaris**：
   - 双哈希表结构
   - TLB和TSB层次
   - 高效的地址转换

6. **交换（Swapping）**：
   - 进程临时交换到磁盘
   - 允许运行比物理内存更大的程序
   - 现代系统使用分页而不是完整交换

7. **内存保护**：
   - 保护位和有效-无效位
   - 防止非法访问
   - 违规触发陷阱

8. **上下文切换和交换**：
   - 交换时间可能很长
   - 减少交换大小可以提高性能
   - 待处理I/O的约束

9. **移动系统交换**：
   - 通常不支持交换
   - 使用其他方法释放内存
   - 支持分页

10. **Intel架构**：
    - IA-32：32位，支持分段和分页
    - IA-64：64位架构
    - PAE：页地址扩展
    - x86-64：当前一代64位架构

11. **ARM架构**：
    - 主导移动平台
    - 两级TLB层次
    - 支持不同页大小

12. **共享页**：
    - 共享代码节省内存
    - 私有代码和数据
    - 写时复制机制

### 学习要点

#### 必须理解的概念

1. **页表结构选择**：
   - 为什么需要不同的页表结构
   - 分层页表、哈希页表、倒置页表的适用场景

2. **64位地址空间**：
   - 为什么需要多级分页
   - 如何减少页表大小

3. **交换机制**：
   - 交换的工作原理
   - 为什么现代系统使用分页而不是交换

4. **内存保护**：
   - 如何实现内存保护
   - 有效-无效位的作用

5. **不同架构**：
   - Intel和ARM架构的区别
   - 不同架构的分页实现

6. **共享页**：
   - 如何实现共享页
   - 共享页的优势和应用

### 实际应用

- **理解现代内存管理**：不同页表结构的实际应用
- **理解性能优化**：如何减少页表大小和访问时间
- **理解内存保护**：如何防止非法访问
- **理解不同架构**：Intel和ARM的内存管理实现
- **理解共享内存**：如何实现进程间共享

### 思考题

1. **为什么64位地址空间需要多级分页？**
   - 页表太大，需要分层管理

2. **哈希页表和倒置页表的区别是什么？**
   - 哈希页表：哈希虚拟页号
   - 倒置页表：每个物理页一个项

3. **为什么现代系统使用分页而不是完整进程交换？**
   - 交换太慢，分页更细粒度

4. **如何实现共享页？**
   - 多个进程的页表项指向同一个物理帧

5. **Intel IA-32和x86-64的区别是什么？**
   - IA-32：32位，支持PAE
   - x86-64：64位，四级分页

---

*希望这个详细讲解能帮助你更好地理解虚拟内存的第二部分内容！如果有任何不清楚的地方，可以随时提问。*

