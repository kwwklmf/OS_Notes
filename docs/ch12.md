# 第12章：I/O系统（I/O Systems）

## 目录
1. [I/O硬件概述](#io硬件概述)
2. [I/O控制方式](#io控制方式)
3. [应用程序I/O接口](#应用程序io接口)
4. [内核I/O子系统](#内核io子系统)
5. [将I/O请求转换为硬件操作](#将io请求转换为硬件操作)
6. [STREAMS](#streams)
7. [性能优化](#性能优化)
8. [电源管理](#电源管理)

---

## I/O硬件概述

### 1. I/O设备的多样性

#### 设备类型
- **存储设备**：硬盘、SSD、USB驱动器
- **传输设备**：网络接口卡、调制解调器
- **人机交互设备**：键盘、鼠标、显示器、触摸屏

#### 共同概念
- I/O设备通过信号与计算机接口
- 需要标准化的接口和协议

### 2. 端口（Port）

#### 定义
- **端口**：设备的连接点
- 设备通过端口连接到计算机系统

#### 端口类型
- **串口**：串行通信
- **并口**：并行通信
- **USB端口**：通用串行总线
- **网络端口**：以太网、Wi-Fi

### 3. 总线（Bus）

#### 定义
- **总线**：连接多个设备的通信路径
- 可以是菊花链（daisy chain）或共享直接访问

#### 常见总线类型

**PCI总线**
- **PCI（Peripheral Component Interconnect）**：PC和服务器中常见
- 用于连接各种扩展卡

**PCI Express（PCIe）**
- **PCIe**：PCI的扩展版本
- 连接相对较慢的设备
- 提供更高的带宽

**SAS总线**
- **SAS（Serial-Attached SCSI）**：常见的磁盘接口
- 用于连接存储设备

**光纤通道（FC）**
- **Fibre Channel**：复杂的控制器
- 通常是独立的电路板（主机总线适配器，HBA）
- 插入总线中

### 4. 控制器（Controller）

#### 定义
- **控制器**：也称为**主机适配器（Host Adapter）**
- 操作端口、总线和设备的电子设备

#### 控制器类型

**集成控制器**
- 有时集成在主板上
- 成本较低，性能可能受限

**独立控制器**
- 有时是独立的电路板
- 包含：
  - **处理器**：执行控制逻辑
  - **微代码**：控制指令
  - **私有内存**：缓存和缓冲
  - **总线控制器**：管理总线通信
  - 等等

#### 设备控制器
- 一些控制器与每个设备的控制器通信
- 每个设备控制器包含：
  - 总线控制器
  - 微代码
  - 内存
  - 等等

### 5. 典型的PC总线结构

```
CPU
 │
 ├─ 内存总线 ── 内存
 │
 ├─ PCI总线 ── 各种PCI设备
 │
 └─ 其他总线 ── 其他设备
```

### 6. I/O指令

#### 控制设备
- I/O指令控制设备
- 设备通常有**寄存器**，设备驱动程序在其中放置：
  - **命令**
  - **地址**
  - **要写入的数据**
  - 或从寄存器读取数据

#### 设备寄存器类型

**1. 数据输入寄存器（Data-In Register）**
- 从设备读取数据

**2. 数据输出寄存器（Data-Out Register）**
- 向设备写入数据

**3. 状态寄存器（Status Register）**
- 包含设备状态信息
- 例如：忙/空闲、错误标志

**4. 控制寄存器（Control Register）**
- 控制设备操作
- 例如：启动、停止、重置

#### 寄存器大小
- 通常1-4字节
- 或FIFO缓冲区（先进先出）

### 7. 设备寻址

#### 直接I/O指令
- 设备有地址
- 通过直接I/O指令使用

#### 内存映射I/O（Memory-Mapped I/O）
- 设备数据和命令寄存器映射到处理器地址空间
- 特别适用于大地址空间（如图形设备）
- 优点：
  - 可以使用普通内存指令访问设备
  - 不需要特殊的I/O指令
  - 更灵活

### 8. PC上的设备I/O端口位置

- 不同设备使用不同的端口地址
- 操作系统需要知道这些地址来与设备通信
- 部分端口地址映射表用于设备管理

---

## I/O控制方式

### 1. 轮询（Polling）

#### 基本过程
对于每个字节的I/O：

1. **读取忙位**：从状态寄存器读取忙位，直到为0
2. **设置读写位**：
   - 主机设置读或写位
   - 如果是写，将数据复制到数据输出寄存器
3. **设置命令就绪位**：主机设置命令就绪位
4. **控制器执行**：
   - 控制器设置忙位
   - 执行传输
5. **完成**：控制器清除忙位、错误位、命令就绪位

#### 特点

**优点**
- 简单直接
- 不需要中断机制
- 适合快速设备

**缺点**
- **忙等待循环**：步骤1是等待I/O的忙等待循环
- **效率低**：如果设备慢，CPU浪费大量时间等待
- **数据丢失风险**：如果错过一个周期，数据可能被覆盖/丢失

#### 适用场景
- 设备速度快
- 实时性要求高
- 简单的嵌入式系统

#### 性能考虑
- 轮询可以在3个指令周期内完成：
  1. 读取状态
  2. 逻辑与提取状态位
  3. 如果不为零则分支
- 如果非零不频繁，如何更高效？→ 使用中断

---

### 2. 中断（Interrupts）

#### 基本概念

**中断请求线**
- CPU有**中断请求线**，由I/O设备触发
- 处理器在每条指令后检查
- 如果检测到中断，处理器：
  1. 保存当前上下文
  2. 跳转到中断处理程序
  3. 执行中断处理
  4. 恢复上下文

#### 中断处理

**中断处理程序**
- **中断处理程序**接收中断
- 根据中断类型执行相应操作

**中断向量**
- **中断向量**：将中断分派到相应的处理程序
- 每个中断类型有唯一的中断向量

**上下文切换**
- 在开始和结束时进行上下文切换
- 保存和恢复CPU状态

**中断优先级**
- 基于优先级处理中断
- 高优先级中断可以中断低优先级中断处理

**可屏蔽中断**
- 某些中断可以**屏蔽**（忽略或延迟）
- 用于关键代码段

**不可屏蔽中断（NMI）**
- 某些中断是**不可屏蔽的**
- 用于关键系统事件（如硬件错误）

**中断链**
- 如果多个设备使用相同的中断号
- 使用**中断链**：依次检查每个设备

#### 中断驱动I/O周期

```
1. 设备完成I/O操作
2. 设备发送中断信号
3. CPU保存当前上下文
4. CPU跳转到中断处理程序
5. 中断处理程序处理I/O完成
6. CPU恢复上下文
7. 继续执行被中断的程序
```

#### 中断的其他用途

**异常处理**
- 中断机制也用于异常
- 例如：
  - 终止进程
  - 由于硬件错误导致系统崩溃

**页面错误**
- 当内存访问错误时执行
- 触发页面换入

**系统调用**
- 通过**陷阱（trap）**执行
- 触发内核执行请求

#### 多CPU系统中的中断

**并发处理**
- 多CPU系统可以并发处理中断
- 如果操作系统设计为处理它

**应用场景**
- 用于时间敏感的处理
- 频繁发生
- 必须快速

#### 中断延迟

**重要性**
- 中断管理压力很大
- 即使是单用户系统也每秒管理数百个中断
- 服务器每秒管理数十万个中断

**示例**
- 一个安静的macOS桌面在10秒内产生了23,000个中断
- 平均每秒2,300个中断！

**优化需求**
- 需要高效的中断处理
- 最小化中断延迟
- 快速的中断处理程序

#### Intel Pentium处理器事件向量表

- 不同的中断类型映射到不同的处理程序
- 向量表定义了中断号到处理程序的映射
- 包括：
  - 硬件中断
  - 软件中断
  - 异常
  - 陷阱

---

### 3. 直接内存访问（DMA - Direct Memory Access）

#### 基本概念

**问题**
- 程序化I/O（一次一个字节）对于大数据移动效率低
- 需要避免CPU参与每个字节的传输

**解决方案**
- 使用**DMA控制器**
- 绕过CPU，直接在I/O设备和内存之间传输数据

#### DMA工作原理

**1. 操作系统准备**
- OS将DMA命令块写入内存
- 命令块包含：
  - **源地址**：数据来源
  - **目标地址**：数据去向
  - **读写模式**：传输方向
  - **字节数**：要传输的数据量

**2. 启动DMA**
- OS将命令块的位置写入DMA控制器
- DMA控制器开始工作

**3. DMA传输**
- **总线主控**：DMA控制器从CPU获取总线
- **周期窃取**：从CPU窃取周期，但效率仍然高得多
- DMA控制器直接访问内存和设备
- CPU可以继续执行其他任务

**4. 完成**
- 传输完成后，DMA控制器发送中断
- 通知CPU传输完成

#### DMA的优势

**性能提升**
- 不需要CPU参与每个字节的传输
- CPU可以执行其他任务
- 大大提高I/O性能

**效率**
- 虽然从CPU窃取周期，但整体效率更高
- 特别适合大数据传输

#### 虚拟地址感知的DMA

**高级版本**
- 某些DMA控制器可以感知虚拟地址
- 可以更高效
- 直接处理虚拟到物理地址转换

#### DMA传输步骤

```
1. 进程请求I/O
2. 设备驱动程序分配DMA缓冲区
3. 设备驱动程序设置DMA命令块
4. 设备驱动程序将命令块地址写入DMA控制器
5. DMA控制器从CPU获取总线
6. DMA控制器执行传输（设备 ↔ 内存）
7. DMA控制器完成，发送中断
8. 中断处理程序通知设备驱动程序
9. 设备驱动程序通知进程
```

#### DMA vs 程序化I/O

| 特性 | 程序化I/O | DMA |
|------|-----------|-----|
| CPU参与 | 每个字节 | 仅设置和完成 |
| 效率 | 低 | 高 |
| 适用场景 | 小数据 | 大数据 |
| CPU利用率 | 高（等待） | 低（可做其他事） |

---

## 应用程序I/O接口

### 1. I/O系统调用

#### 基本概念
- **I/O系统调用**将设备行为封装在通用类中
- 提供统一的接口，隐藏设备差异

#### 设备驱动层
- **设备驱动层**向内核隐藏I/O控制器的差异
- 新设备如果使用已实现的协议，不需要额外工作
- 每个操作系统有自己的I/O子系统结构和设备驱动框架

### 2. I/O设备的维度

设备在多个维度上变化：

#### 1. 数据组织
- **字符流（Character-Stream）**：键盘、鼠标
- **块（Block）**：磁盘

#### 2. 访问方式
- **顺序（Sequential）**：磁带
- **随机访问（Random-Access）**：磁盘

#### 3. 同步性
- **同步（Synchronous）**：等待完成
- **异步（Asynchronous）**：不等待完成
- **或两者**：支持两种模式

#### 4. 共享性
- **可共享（Sharable）**：多个进程可同时访问
- **专用（Dedicated）**：一次只能一个进程访问

#### 5. 操作速度
- 从慢（键盘）到快（网络、磁盘）

#### 6. 读写能力
- **读写（read-write）**：可读可写
- **只读（read only）**：只能读
- **只写（write only）**：只能写

### 3. 内核I/O结构

#### 层次结构
```
应用程序
   │
   ├─ 系统调用接口
   │
   ├─ 内核I/O子系统
   │   ├─ 调度
   │   ├─ 缓冲
   │   ├─ 缓存
   │   ├─ 假脱机
   │   └─ 错误处理
   │
   ├─ 设备驱动层
   │
   └─ 硬件设备
```

### 4. 设备特性

#### 设备驱动的微妙之处
- 设备驱动处理设备的微妙之处
- 操作系统可以将I/O设备广泛分组为：

**1. 块I/O**
- 磁盘驱动器
- 命令包括：read、write、seek
- 访问方式：
  - **原始I/O（Raw I/O）**
  - **直接I/O（Direct I/O）**
  - **文件系统访问**
- **内存映射文件访问**可能：
  - 文件映射到虚拟内存
  - 通过需求分页引入簇

**2. 字符I/O（流）**
- 键盘、鼠标、串口
- 命令包括：get()、put()
- 在顶部分层的库允许行编辑

**3. 内存映射文件访问**
- 文件映射到虚拟内存空间
- 通过内存操作访问文件

**4. 网络套接字**
- 网络通信
- 特殊的接口和处理方式

#### 直接操作设备
- 对于直接操作I/O设备的特定特性
- 通常使用**转义/后门**
- **Unix ioctl()调用**：
  - 向设备控制寄存器发送任意位
  - 向设备数据寄存器发送数据

#### 设备编号
- **UNIX和Linux**使用"主"和"次"设备编号的元组
- 标识设备的类型和实例
- 示例：`ls -l /dev/sda*`
  - 主设备号：8（磁盘类型）
  - 次设备号：0-4（不同分区）

---

### 5. 块设备和字符设备

#### 块设备
**包括**
- 磁盘驱动器

**命令**
- read：读取数据
- write：写入数据
- seek：定位到特定位置

**访问方式**
- **原始I/O（Raw I/O）**：直接访问块，绕过文件系统
- **直接I/O（Direct I/O）**：直接访问，但通过文件系统
- **文件系统访问**：通过文件系统接口

**内存映射文件访问**
- 文件可以映射到虚拟内存
- 通过需求分页引入簇
- 提供类似内存的访问方式

#### 字符设备
**包括**
- 键盘
- 鼠标
- 串口

**命令**
- get()：获取字符
- put()：输出字符

**库支持**
- 在顶部分层的库允许行编辑
- 提供更高级的接口

---

### 6. 网络设备

#### 特点
- 与块和字符设备差异很大
- 需要自己的接口

#### 系统支持
- Linux、Unix、Windows和许多其他系统包括**套接字接口**
- 将网络协议与网络操作分离
- 包括select()功能

#### 方法变化
- 方法差异很大：
  - **管道（Pipes）**
  - **FIFO**
  - **流（Streams）**
  - **队列（Queues）**
  - **邮箱（Mailboxes）**

---

### 7. 时钟和定时器

#### 功能
- **提供当前时间**：系统时间
- **提供经过时间**：从某个点开始的时间
- **定时器**：在特定时间触发事件

#### 分辨率
- **正常分辨率**：约1/60秒
- **高分辨率定时器**：某些系统提供更高分辨率

#### 可编程间隔定时器
- 用于定时
- 周期性中断
- 用于调度、超时等

#### 系统调用
- **ioctl()**（在UNIX上）涵盖I/O的奇怪方面
- 如时钟和定时器

---

### 8. 非阻塞和异步I/O

#### 阻塞I/O（Blocking I/O）

**特点**
- 进程挂起直到I/O完成
- 简单易用和理解

**问题**
- 对某些需求不足
- 进程在I/O期间无法做其他事情

#### 非阻塞I/O（Nonblocking I/O）

**特点**
- I/O调用立即返回可用数据
- 不等待完整数据

**实现方式**
- **用户界面**：立即返回
- **数据复制**：缓冲I/O
- **多线程实现**：通过多线程
- 快速返回读取或写入的字节数

**使用模式**
- **select()**查找数据是否就绪
- 然后read()或write()传输

**示例**
```c
// 非阻塞读取
fd = open("/dev/device", O_NONBLOCK);
n = read(fd, buffer, size);
if (n > 0) {
    // 处理数据
} else if (n == 0) {
    // 没有数据可用
} else {
    // 错误处理
}
```

#### 异步I/O（Asynchronous I/O）

**特点**
- 进程在I/O执行时运行
- 难以使用
- I/O子系统在I/O完成时向进程发送信号

**优势**
- 进程可以继续执行其他任务
- 不阻塞

**挑战**
- 需要信号处理
- 错误处理更复杂

**示例**
```c
// 异步I/O
aio_read(&aiocb);  // 启动异步读取
// 继续执行其他任务
// I/O完成时收到信号
```

#### 两种I/O方法对比

**同步方法**
- **(a) 阻塞**：等待完成
- **(b) 非阻塞**：立即返回，轮询检查

**异步方法**
- 启动I/O后立即返回
- I/O完成时通知

---

### 9. 向量I/O（Vectored I/O）

#### 基本概念
- **向量I/O**允许一个系统调用执行多个I/O操作
- 也称为**分散-聚集（Scatter-Gather）**方法

#### 示例
- **Unix readv()**：接受多个缓冲区的向量
- 可以读取到多个缓冲区或从多个缓冲区写入

#### 优势
- **减少上下文切换**：一个系统调用而不是多个
- **减少系统调用开销**：更少的系统调用
- **原子性**：某些版本提供原子性
- **避免竞争条件**：例如，不用担心多个线程在读取/写入发生时更改数据

#### 使用场景
- 需要从多个位置读取或写入多个位置
- 减少系统调用次数
- 提高性能

---

## 内核I/O子系统

### 1. 调度（Scheduling）

#### 基本概念
- 通过每个设备的队列进行某些I/O请求排序
- 操作系统尝试公平性
- 某些实现**服务质量（QoS）**，例如IPQOS

#### 调度目标
- **公平性**：所有进程公平访问
- **性能**：优化I/O性能
- **优先级**：支持优先级调度

#### 调度算法
- 类似磁盘调度算法
- 但适用于所有I/O设备
- 考虑设备特性

---

### 2. 缓冲（Buffering）

#### 目的
- 在设备之间传输时在内存中存储数据

#### 原因

**1. 处理设备速度不匹配**
- 快速设备 → 慢速设备
- 慢速设备 → 快速设备
- 缓冲平滑速度差异

**2. 处理设备传输大小不匹配**
- 不同设备有不同的传输单元大小
- 缓冲适配大小差异

**3. 维护"复制语义"**
- 确保数据一致性
- 防止数据损坏

#### 双缓冲（Double Buffering）
- **两个数据副本**：
  - 内核和用户
- **不同大小**：
  - 完整/正在处理
  - 未满/正在使用

#### 写时复制（Copy-on-Write）
- 在某些情况下可用于效率
- 延迟复制直到需要修改

---

### 3. 缓存（Caching）

#### 基本概念
- **更快的设备**保存数据的副本
- **总是只是副本**
- **性能的关键**

#### 缓存策略
- 有时与缓冲结合
- 减少对慢速设备的访问
- 提高性能

#### 缓存管理
- 缓存替换算法
- 缓存一致性
- 缓存大小调整

---

### 4. 假脱机（Spooling）

#### 定义
- **假脱机**：为设备保存输出
- 如果设备一次只能服务一个请求
- 例如：**打印**

#### 工作原理
```
进程1 → 假脱机文件1
进程2 → 假脱机文件2
进程3 → 假脱机文件3
         ↓
    打印机（一次一个）
```

#### 优势
- 进程不需要等待设备
- 设备可以按顺序处理请求
- 提高系统效率

---

### 5. 设备预留（Device Reservation）

#### 定义
- 提供对设备的**独占访问**
- 系统调用用于分配和释放

#### 用途
- 确保设备不被其他进程使用
- 防止数据冲突

#### 注意事项
- **小心死锁**！
- 多个进程预留多个设备可能导致死锁
- 需要死锁预防或检测

---

### 6. 错误处理（Error Handling）

#### 可恢复错误
- 操作系统可以从以下错误中恢复：
  - **磁盘读取错误**：重试读取
  - **设备不可用**：等待或使用备用设备
  - **瞬态写入失败**：重试写入

#### 高级错误处理
- 某些系统更高级，如**Solaris FMA**、**AIX**
- **跟踪错误频率**
- **停止使用**错误频率增加的设备
- 可重试错误

#### 错误报告
- 大多数在I/O请求失败时返回错误号或代码
- **系统错误日志**保存问题报告
- 用于诊断和调试

---

### 7. I/O保护（I/O Protection）

#### 问题
- 用户进程可能意外或故意尝试通过非法I/O指令破坏正常操作

#### 解决方案
- **所有I/O指令定义为特权指令**
- **I/O必须通过系统调用执行**
- **内存映射和I/O端口内存位置也必须受到保护**

#### 保护机制
```
用户模式
   │
   ├─ 尝试直接I/O指令 → 被阻止（特权指令）
   │
   └─ 使用系统调用 → 允许
         │
         ↓
   内核模式
         │
         └─ 执行I/O操作
```

#### 使用系统调用执行I/O
- 用户进程调用系统调用
- 内核验证权限
- 内核执行I/O操作
- 返回结果给用户进程

---

### 8. 内核数据结构

#### 状态信息
- 内核为I/O组件保持状态信息，包括：
  - **打开文件表**
  - **网络连接**
  - **字符设备状态**

#### 复杂数据结构
- 许多复杂的跟踪数据结构：
  - **缓冲区**
  - **内存分配**
  - **"脏"块**

#### 实现方法

**面向对象方法**
- 某些使用面向对象方法和消息传递实现I/O

**Windows消息传递**
- Windows使用消息传递
- 带有I/O信息的消息从用户模式传递到内核
- 消息在流向设备驱动程序和返回进程时被修改

**优缺点**
- **优点**：
  - 灵活
  - 易于扩展
  - 模块化
- **缺点**：
  - 可能较慢
  - 更复杂

---

### 9. UNIX I/O内核结构

#### 文件描述符
- 每个打开的文件有文件描述符
- 文件描述符指向文件表项

#### 文件表
- 包含文件状态信息
- 文件偏移量
- 访问模式

#### inode表
- 包含文件元数据
- 文件权限
- 文件大小
- 数据块位置

#### 设备表
- 跟踪设备状态
- 设备驱动信息

---

### 10. 设备状态表

#### 内容
- 跟踪每个设备的状态
- 包括：
  - 设备类型
  - 设备地址
  - 设备状态（忙/空闲）
  - 当前操作
  - 等待队列

---

### 11. I/O设备和接口速度

#### 速度范围
- 设备速度差异很大：
  - **键盘**：非常慢（人类输入速度）
  - **鼠标**：慢
  - **串口**：慢到中等
  - **USB 2.0**：中等
  - **USB 3.0**：快
  - **SATA**：快
  - **PCIe**：非常快
  - **内存总线**：极快

#### 性能考虑
- 需要匹配设备速度
- 使用适当的缓冲和缓存
- 优化I/O路径

---

### 12. 内核I/O子系统总结

内核I/O子系统协调大量服务，这些服务可用于应用程序和内核的其他部分：

1. **文件和设备命名空间管理**
2. **文件和设备的访问控制**
3. **操作控制**（例如，调制解调器不能seek()）
4. **文件系统空间分配**
5. **设备分配**
6. **缓冲、缓存和假脱机**
7. **I/O调度**
8. **设备状态监控、错误处理和故障恢复**
9. **设备驱动配置和初始化**
10. **I/O设备的电源管理**

I/O子系统的上层通过设备驱动提供的统一接口访问设备。

---

## 将I/O请求转换为硬件操作

### 1. 基本过程

考虑从磁盘为进程读取文件：

#### 步骤1：确定设备
- 确定保存文件的设备
- 查找文件系统信息

#### 步骤2：名称转换
- 将名称转换为设备表示
- 文件名 → 设备号 → 设备驱动

#### 步骤3：物理读取
- 从磁盘物理读取数据到缓冲区
- 设备驱动执行实际I/O操作

#### 步骤4：数据可用
- 使数据可用于请求进程
- 将数据从内核缓冲区复制到用户空间

#### 步骤5：返回控制
- 将控制返回给进程
- 进程可以继续执行

### 2. I/O请求生命周期

```
用户进程
   │
   ├─ 1. 请求I/O（系统调用）
   │      ↓
   ├─ 2. 内核I/O子系统
   │      ├─ 验证权限
   │      ├─ 分配资源
   │      └─ 调度I/O
   │      ↓
   ├─ 3. 设备驱动
   │      ├─ 准备设备
   │      ├─ 启动I/O操作
   │      └─ 等待完成
   │      ↓
   ├─ 4. 设备控制器
   │      ├─ 执行物理I/O
   │      └─ 发送中断
   │      ↓
   ├─ 5. 中断处理
   │      ├─ 处理完成
   │      └─ 通知驱动
   │      ↓
   ├─ 6. 设备驱动
   │      ├─ 检查状态
   │      └─ 更新数据结构
   │      ↓
   ├─ 7. 内核I/O子系统
   │      ├─ 复制数据
   │      └─ 更新状态
   │      ↓
   └─ 8. 用户进程
          ├─ 接收数据
          └─ 继续执行
```

### 3. 详细流程

#### 阶段1：请求阶段
- 用户进程调用read()系统调用
- 传递文件描述符、缓冲区、大小

#### 阶段2：内核处理
- 内核验证文件描述符
- 检查权限
- 查找文件inode
- 确定设备

#### 阶段3：设备驱动
- 设备驱动准备I/O操作
- 设置DMA或程序化I/O
- 启动设备

#### 阶段4：设备执行
- 设备控制器执行物理I/O
- 从磁盘读取数据
- 传输到内存

#### 阶段5：完成通知
- 设备发送中断
- 中断处理程序处理
- 通知设备驱动

#### 阶段6：数据传递
- 从内核缓冲区复制到用户缓冲区
- 更新文件偏移量
- 返回读取的字节数

---

## STREAMS

### 1. 基本概念

#### 定义
- **STREAM**：在Unix System V及更高版本中，用户级进程和设备之间的**全双工通信通道**

#### 全双工
- 可以同时双向通信
- 读和写可以同时进行

### 2. STREAM结构

STREAM由以下部分组成：

#### 1. STREAM头（STREAM Head）
- 与用户进程接口
- 用户进程通过STREAM头与STREAM通信

#### 2. 驱动端（Driver End）
- 与设备接口
- 设备驱动通过驱动端与STREAM通信

#### 3. STREAM模块（STREAM Modules）
- **零个或多个**STREAM模块在它们之间
- 每个模块包含：
  - **读队列**：处理读取数据
  - **写队列**：处理写入数据

### 3. 消息传递

#### 通信方式
- **消息传递**用于在队列之间通信
- 数据作为消息在模块之间传递

#### 流控制
- **流控制选项**指示可用或忙碌
- 防止缓冲区溢出
- 管理数据流

### 4. 同步和异步

#### 内部异步
- STREAM内部是**异步的**
- 模块可以并发处理消息

#### 用户接口同步
- 用户进程与STREAM头的通信是**同步的**
- 提供简单的接口

### 5. STREAM的优势

#### 模块化
- 可以添加/删除模块
- 灵活配置

#### 可扩展性
- 易于添加新功能
- 可以堆叠模块

#### 灵活性
- 支持不同的设备类型
- 支持不同的协议

### 6. STREAM结构示例

```
用户进程
   │
   ↓
STREAM头
   │
   ↓
模块1（例如：行编辑）
   │
   ↓
模块2（例如：协议转换）
   │
   ↓
驱动端
   │
   ↓
设备
```

---

## 性能优化

### 1. I/O性能的重要性

#### I/O是系统性能的主要因素

**CPU使用**
- 需要CPU执行设备驱动
- 需要CPU执行内核I/O代码

**上下文切换**
- 由于中断导致上下文切换
- 每次中断都需要上下文切换

**数据复制**
- 数据在用户空间和内核空间之间复制
- 可能多次复制

**网络流量**
- 网络流量特别有压力
- 高延迟、低带宽

### 2. 性能瓶颈

#### 1. 上下文切换开销
- 每次系统调用需要上下文切换
- 每次中断需要上下文切换
- 开销很大

#### 2. 数据复制开销
- 用户空间 ↔ 内核空间
- 内核空间 ↔ 设备缓冲区
- 多次复制浪费CPU和内存带宽

#### 3. 中断开销
- 频繁中断
- 中断处理开销
- 上下文切换开销

#### 4. 网络延迟
- 网络通信延迟高
- 带宽可能受限

### 3. 性能改进方法

#### 1. 减少上下文切换
- **批量系统调用**：一次处理多个操作
- **减少系统调用**：使用更大的缓冲区
- **用户空间I/O**：某些情况下在用户空间处理

#### 2. 减少数据复制
- **零拷贝技术**：直接从设备到用户空间
- **内存映射**：共享内存，避免复制
- **DMA**：直接内存访问，减少CPU参与

#### 3. 减少中断
- **使用大传输**：减少中断频率
- **智能控制器**：批量处理
- **轮询**：在某些情况下使用轮询代替中断

#### 4. 使用DMA
- 直接内存访问
- 减少CPU参与
- 提高效率

#### 5. 使用更智能的硬件设备
- 设备内置处理能力
- 减少主机CPU负载

#### 6. 平衡性能
- 平衡CPU、内存、总线和I/O性能
- 获得最高吞吐量
- 避免瓶颈

#### 7. 移动用户模式进程/守护进程到内核线程
- 减少上下文切换
- 提高性能
- 但增加内核复杂性

### 4. 设备功能性能

#### 存储和网络延迟
- 不同设备有不同的延迟特性
- 需要针对不同设备优化

#### I/O性能范围
- 从非常慢（键盘）到非常快（内存）
- 需要不同的优化策略

### 5. 性能测量

#### 指标
- **吞吐量**：每秒处理的I/O操作数
- **延迟**：单个I/O操作的响应时间
- **CPU利用率**：I/O处理使用的CPU时间
- **带宽利用率**：使用的总线带宽百分比

#### 工具
- 性能分析工具
- 系统监控工具
- 基准测试工具

---

## 电源管理

### 1. 基本概念

#### 重要性
- 不严格属于I/O领域，但很多与I/O相关
- 计算机和设备使用电力，产生热量
- 经常需要冷却

#### 操作系统的作用
- 操作系统可以帮助管理和改善使用
- 提高能效
- 延长电池寿命（移动设备）

### 2. 云计算环境

#### 虚拟机迁移
- 云计算环境在服务器之间移动虚拟机
- 可以最终清空整个系统并关闭它们
- 节省电力

#### 动态资源管理
- 根据负载调整资源
- 关闭未使用的服务器
- 提高能效

### 3. 移动计算

#### 第一类OS方面
- 移动计算将电源管理作为第一类OS方面
- 电池寿命至关重要
- 需要智能电源管理

### 4. 组件级电源管理

#### 设备树
- **理解组件之间的关系**
- **构建设备树**表示物理设备拓扑
- 例如：系统总线 → I/O子系统 → {闪存、USB存储}

#### 设备状态跟踪
- **设备驱动跟踪设备状态**，是否在使用
- **未使用的组件**：关闭它
- **树分支中所有设备未使用**：关闭分支

#### 层次管理
```
系统总线（如果所有子设备未使用，可以降低频率）
   │
   ├─ I/O子系统
   │   │
   │   ├─ 闪存（如果未使用，可以关闭）
   │   │
   │   └─ USB存储（如果未使用，可以关闭）
```

### 5. Android电源管理

#### 唤醒锁（Wake Locks）
- 像其他锁一样
- 但当锁被持有时防止设备睡眠
- 确保关键操作完成

#### 电源崩溃（Power Collapse）
- 将设备置于非常深的睡眠
- **边际功耗**
- 只足够响应外部刺激（按钮按下、来电）

### 6. ACPI（高级配置和电源接口）

#### 定义
- **ACPI**：现代系统使用的高级配置和电源接口
- **固件**提供代码
- 作为例程运行，由内核调用

#### 功能
- **设备发现**：发现系统中的设备
- **管理**：管理设备
- **错误管理**：处理错误
- **电源管理**：管理电源

#### 优势
- 标准化接口
- 硬件和操作系统之间的协作
- 更好的电源管理

### 7. 电源管理策略

#### 1. 动态电压和频率缩放（DVFS）
- 根据负载调整CPU频率和电压
- 降低负载时降低频率和电压
- 节省电力

#### 2. 设备休眠
- 未使用的设备进入休眠模式
- 降低功耗
- 需要时快速唤醒

#### 3. CPU空闲状态
- CPU空闲时进入低功耗状态
- C-states：不同的空闲级别
- 深度空闲状态节省更多电力

#### 4. 显示管理
- 降低显示亮度
- 关闭未使用的显示
- 屏幕超时

#### 5. 网络管理
- 未使用时降低网络接口功耗
- Wi-Fi、蓝牙等

---

## 总结

### 关键概念

1. **I/O硬件**
   - 端口、总线、控制器
   - 设备寄存器和内存映射I/O
   - 设备寻址

2. **I/O控制方式**
   - 轮询：简单但效率低
   - 中断：高效，适合大多数情况
   - DMA：大数据传输的最佳选择

3. **应用程序I/O接口**
   - 系统调用封装设备差异
   - 块设备、字符设备、网络设备
   - 阻塞、非阻塞、异步I/O

4. **内核I/O子系统**
   - 调度、缓冲、缓存
   - 假脱机、设备预留
   - 错误处理、I/O保护

5. **性能优化**
   - 减少上下文切换
   - 减少数据复制
   - 使用DMA和智能硬件

6. **电源管理**
   - 组件级管理
   - 设备树和层次管理
   - ACPI和现代电源管理

### 实际应用

- **设备驱动开发**：需要理解I/O硬件和控制方式
- **系统编程**：需要理解I/O系统调用和接口
- **性能优化**：需要理解I/O性能瓶颈和优化方法
- **嵌入式系统**：需要理解电源管理和资源管理

### 学习要点

#### 必须理解的概念

1. **I/O硬件结构**：端口、总线、控制器
2. **I/O控制方式**：轮询、中断、DMA
3. **I/O接口**：系统调用、设备类型
4. **内核I/O子系统**：调度、缓冲、缓存
5. **性能优化**：减少开销、使用DMA

#### 必须掌握的知识

1. **中断处理流程**
2. **DMA工作原理**
3. **I/O请求生命周期**
4. **性能优化技术**

#### 实际应用场景

1. **编写设备驱动**：需要理解硬件和控制方式
2. **优化I/O性能**：需要理解性能瓶颈
3. **设计I/O系统**：需要理解系统架构
4. **电源管理**：移动设备和嵌入式系统

---

*本文档基于《操作系统概念》第10版第12章内容整理*

