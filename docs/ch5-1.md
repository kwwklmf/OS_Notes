# 第5章：CPU调度（第一部分）- 详细讲解

## 目录
1. [基本概念（Basic Concepts）](#基本概念)
2. [CPU调度器（CPU Scheduler）](#cpu调度器)
3. [抢占式和非抢占式调度（Preemptive and Nonpreemptive Scheduling）](#抢占式和非抢占式调度)
4. [分发器（Dispatcher）](#分发器)
5. [调度准则（Scheduling Criteria）](#调度准则)
6. [先来先服务调度（FCFS Scheduling）](#先来先服务调度)
7. [最短作业优先调度（SJF Scheduling）](#最短作业优先调度)
8. [最短剩余时间优先调度（SRTF Scheduling）](#最短剩余时间优先调度)
9. [时间片轮转调度（Round Robin Scheduling）](#时间片轮转调度)
10. [优先级调度（Priority Scheduling）](#优先级调度)

---

## 基本概念（Basic Concepts）

### 1. 多道程序设计的CPU利用率

#### 最大CPU利用率
- **通过多道程序设计获得最大CPU利用率**
- **让CPU尽可能忙碌**

#### CPU-I/O突发周期（CPU–I/O Burst Cycle）

**定义**：
- **进程执行由CPU执行和I/O等待的周期组成**
- **CPU突发（CPU Burst）后跟I/O突发（I/O Burst）**

**周期**：
```
CPU突发 → I/O等待 → CPU突发 → I/O等待 → ...
```

#### CPU突发分布
- **CPU突发分布是主要关注点**
- **大多数CPU突发时间较短**
- **少数CPU突发时间较长**

### 2. CPU突发时间直方图（Histogram of CPU-burst Times）

#### 特点
- **大量短突发**
- **少量长突发**

#### 分布
```
CPU突发时间分布：
┌─────────────────────────────────┐
│ 大量短突发（< 10ms）              │
│ 中等突发（10-100ms）              │
│ 少量长突发（> 100ms）              │
└─────────────────────────────────┘
```

#### 意义
- **大多数进程是I/O密集型的**
- **CPU突发时间短**
- **调度算法应该优化短突发**

---

## CPU调度器（CPU Scheduler）

### 1. 什么是CPU调度器？

#### 定义
- **CPU调度器从就绪队列（Ready Queue）中的进程中选择**
- **将CPU核心分配给其中一个进程**
- **队列可以以各种方式排序**

#### 类比理解
想象CPU调度器是任务分配员：
- **就绪队列** = 等待处理的任务列表
- **CPU调度器** = 任务分配员
- **决定**：哪个任务先做，做多久

### 2. CPU调度决策时机

#### CPU调度决策可能在以下情况发生：

**① 进程从运行切换到等待状态**
- **进程请求I/O**
- **必须等待I/O完成**
- **CPU空闲，需要选择新进程**

**② 进程从运行切换到就绪状态**
- **时间片用完**
- **被更高优先级进程抢占**
- **需要选择下一个进程**

**③ 进程从等待切换到就绪**
- **I/O完成**
- **进程可以继续执行**
- **可能需要抢占当前进程**

**④ 进程终止**
- **进程执行完毕**
- **CPU空闲**
- **需要选择新进程**

### 3. 调度决策的选择

#### 没有选择的情况
- **情况1和4**：没有选择
- **新进程（如果就绪队列中存在）必须被选择执行**

#### 有选择的情况
- **情况2和3**：有选择
- **可以继续运行当前进程**
- **或切换到另一个进程**

---

## 抢占式和非抢占式调度（Preemptive and Nonpreemptive Scheduling）

### 1. 非抢占式调度（Nonpreemptive Scheduling）

#### 定义
- **调度只在情况1和4下发生**
- **一旦CPU被分配给进程，进程保持CPU直到它释放**
- **通过终止或切换到等待状态释放**

#### 特点
- **进程主动放弃CPU**
- **不会被强制中断**
- **简单但可能不公平**

#### 例子
- **早期操作系统**
- **某些实时系统**

### 2. 抢占式调度（Preemptive Scheduling）

#### 定义
- **调度在情况2和3下也发生**
- **进程可以被强制中断**
- **CPU可以被重新分配**

#### 特点
- **操作系统可以中断进程**
- **更灵活**
- **更公平**

#### 现代系统
- **几乎所有现代操作系统使用抢占式调度算法**
- **包括**：
  - **Windows**
  - **macOS**
  - **Linux**
  - **UNIX**

### 3. 抢占式调度和竞争条件（Race Conditions）

#### 问题
- **抢占式调度可能导致竞争条件**
- **当数据在多个进程之间共享时**

#### 场景
- **两个进程共享数据**
- **一个进程正在更新数据时被抢占**
- **第二个进程运行并尝试读取数据**
- **数据处于不一致状态**

#### 解决方案
- **同步机制**（将在第6章详细讨论）
- **互斥锁（Mutex）**
- **信号量（Semaphore）**

---

## 分发器（Dispatcher）

### 1. 什么是分发器？

#### 定义
- **分发器模块将CPU控制权交给CPU调度器选择的进程**
- **涉及以下操作**：

**① 切换上下文（Switching Context）**
- **保存旧进程的状态**
- **加载新进程的状态**

**② 切换到用户模式（Switching to User Mode）**
- **从内核模式切换到用户模式**

**③ 跳转到用户程序中的正确位置（Jumping to Proper Location）**
- **跳转到用户程序中的正确位置以重启该程序**

### 2. 分发延迟（Dispatch Latency）

#### 定义
- **分发器停止一个进程并启动另一个进程运行所需的时间**
- **调度开销的一部分**

#### 组成部分
- **上下文切换时间**
- **模式切换时间**
- **跳转时间**

#### 优化
- **减少分发延迟**
- **提高系统效率**

---

## 调度准则（Scheduling Criteria）

### 1. 调度准则

#### ① CPU利用率（CPU Utilization）
- **保持CPU尽可能忙碌**
- **目标**：最大化CPU利用率

#### ② 吞吐量（Throughput）
- **每个时间单位完成执行的进程数**
- **目标**：最大化吞吐量

#### ③ 周转时间（Turnaround Time）
- **执行特定进程所需的时间量**
- **从提交到完成的总时间**
- **目标**：最小化周转时间

#### ④ 等待时间（Waiting Time）
- **进程在就绪队列中等待的时间量**
- **不包括执行时间和I/O时间**
- **目标**：最小化等待时间

#### ⑤ 响应时间（Response Time）
- **从提交请求到产生第一个响应所需的时间量**
- **对交互式系统很重要**
- **目标**：最小化响应时间

### 2. 调度算法优化准则

#### 目标
- **最大CPU利用率**
- **最大吞吐量**
- **最小周转时间**
- **最小等待时间**
- **最小响应时间**

#### 权衡
- **这些目标可能冲突**
- **需要根据系统类型选择重点**

---

## 先来先服务调度（FCFS Scheduling）

### 1. 什么是FCFS？

#### 定义
- **FCFS（First-Come-First-Served）**：先来先服务
- **最简单的调度算法**
- **按照进程到达的顺序执行**

#### 类比理解
想象FCFS是排队：
- **进程** = 顾客
- **CPU** = 服务窗口
- **先来的先服务**

### 2. FCFS示例1

#### 场景
- **进程到达顺序**：P1, P2, P3
- **突发时间（Burst Time）**：
  - P1: 24
  - P2: 3
  - P3: 3

#### 甘特图（Gantt Chart）

```
时间线：
0 ──────────────── 24 ─── 27 ─── 30
│      P1         │  P2  │ P3 │
```

#### 等待时间计算

**P1的等待时间**：
- **到达时间**：0
- **开始执行**：0
- **等待时间**：0

**P2的等待时间**：
- **到达时间**：0（假设同时到达）
- **开始执行**：24
- **等待时间**：24

**P3的等待时间**：
- **到达时间**：0（假设同时到达）
- **开始执行**：27
- **等待时间**：27

#### 平均等待时间
```
平均等待时间 = (0 + 24 + 27) / 3 = 17
```

### 3. FCFS示例2

#### 场景
- **进程到达顺序**：P2, P3, P1
- **突发时间**：
  - P1: 24
  - P2: 3
  - P3: 3

#### 甘特图

```
时间线：
0 ─── 3 ─── 6 ──────────────── 30
│ P2 │ P3 │        P1         │
```

#### 等待时间计算

**P1的等待时间**：
- **到达时间**：0（假设）
- **开始执行**：6
- **等待时间**：6

**P2的等待时间**：
- **到达时间**：0
- **开始执行**：0
- **等待时间**：0

**P3的等待时间**：
- **到达时间**：0（假设）
- **开始执行**：3
- **等待时间**：3

#### 平均等待时间
```
平均等待时间 = (6 + 0 + 3) / 3 = 3
```

**比前一种情况好得多！**

### 4. FCFS的问题

#### 护航效应（Convoy Effect）
- **短进程在长进程后面**
- **短进程必须等待长进程完成**
- **导致平均等待时间增加**

#### 例子
- **考虑一个CPU密集型进程和许多I/O密集型进程**
- **CPU密集型进程占用CPU很长时间**
- **I/O密集型进程必须等待**
- **即使它们只需要很短的CPU时间**

### 5. FCFS的特点

#### 优点
- **简单**
- **易于实现**
- **公平（按到达顺序）**

#### 缺点
- **平均等待时间可能很长**
- **护航效应**
- **不适合交互式系统**

---

## 最短作业优先调度（SJF Scheduling）

### 1. 什么是SJF？

#### 定义
- **SJF（Shortest-Job-First）**：最短作业优先
- **与每个进程关联其下一个CPU突发的长度**
- **使用这些长度调度最短时间的进程**

#### 关键点
- **SJF是最优的**
- **对于给定的进程集，给出最小平均等待时间**

### 2. SJF示例

#### 场景
- **进程突发时间**：
  - P1: 6
  - P2: 8
  - P3: 7
  - P4: 3

#### 调度顺序
- **按突发时间排序**：P4(3) → P1(6) → P3(7) → P2(8)

#### 甘特图

```
时间线：
0 ─── 3 ─── 9 ─── 16 ─── 24
│ P4 │  P1  │  P3  │  P2  │
```

#### 等待时间计算

**P1的等待时间**：
- **开始执行**：3
- **等待时间**：3

**P2的等待时间**：
- **开始执行**：16
- **等待时间**：16

**P3的等待时间**：
- **开始执行**：9
- **等待时间**：9

**P4的等待时间**：
- **开始执行**：0
- **等待时间**：0

#### 平均等待时间
```
平均等待时间 = (3 + 16 + 9 + 0) / 4 = 7
```

### 3. 如何确定下一个CPU突发的长度？

#### 问题
- **我们不知道下一个CPU突发的实际长度**
- **只能估计**

#### 方法

**① 询问用户**
- **用户可以估计**
- **但用户可能不知道或不准确**

**② 估计（Estimate）**
- **应该与之前的类似**
- **使用之前的CPU突发长度**
- **使用指数平均（Exponential Averaging）**

### 4. 指数平均（Exponential Averaging）

#### 公式

```
τ(n+1) = α * t(n) + (1 - α) * τ(n)
```

其中：
- **τ(n+1)**：下一个CPU突发的预测长度
- **t(n)**：第n个CPU突发的实际长度
- **τ(n)**：第n个CPU突发的预测长度
- **α**：平滑参数（0 ≤ α ≤ 1）

#### 常用值
- **α通常设置为1/2**

### 5. 指数平均的例子

#### α = 0
```
τ(n+1) = τ(n)
```
- **最近的历史不算数**
- **只使用初始估计**

#### α = 1
```
τ(n+1) = t(n)
```
- **只有实际的最后一个CPU突发算数**
- **忽略历史**

#### 展开公式
```
τ(n+1) = α * t(n) + (1 - α) * α * t(n-1) + ... + (1 - α)^j * α * t(n-j) + ... + (1 - α)^(n+1) * τ(0)
```

#### 权重
- **由于α和(1 - α)都小于或等于1**
- **每个后续项比其前驱项权重更小**
- **最近的突发权重最大**

### 6. SJF的特点

#### 优点
- **最小平均等待时间**
- **理论上最优**

#### 缺点
- **难以预测下一个CPU突发长度**
- **可能导致长作业饥饿（Starvation）**
- **不适合交互式系统**

---

## 最短剩余时间优先调度（SRTF Scheduling）

### 1. 什么是SRTF？

#### 定义
- **SRTF（Shortest-Remaining-Time-First）**：最短剩余时间优先
- **SJF的抢占式版本**
- **每当新进程到达就绪队列时，使用SJF算法重新决定调度哪个进程**

### 2. SRTF vs SJF

#### 问题
- **SRTF在最小平均等待时间方面是否比SJF更"最优"？**

#### 答案
- **对于给定的进程集，SRTF通常给出更小的平均等待时间**
- **因为可以抢占长进程，让短进程先执行**

### 3. SRTF示例

#### 场景
- **进程到达时间和突发时间**：
  - P1: 到达时间0，突发时间8
  - P2: 到达时间1，突发时间4
  - P3: 到达时间2，突发时间9
  - P4: 到达时间3，突发时间5

#### 调度过程

**时间0**：
- **P1到达，开始执行**
- **剩余时间：8**

**时间1**：
- **P2到达，突发时间4 < P1剩余时间7**
- **抢占P1，执行P2**
- **P1剩余时间：7**

**时间2**：
- **P3到达，突发时间9 > P2剩余时间3**
- **继续执行P2**

**时间3**：
- **P4到达，突发时间5 > P2剩余时间2**
- **继续执行P2**

**时间5**：
- **P2完成**
- **选择最短剩余时间：P4(5) < P1(7) < P3(9)**
- **执行P4**

**时间10**：
- **P4完成**
- **选择最短剩余时间：P1(7) < P3(9)**
- **执行P1**

**时间17**：
- **P1完成**
- **执行P3**

**时间26**：
- **P3完成**

#### 甘特图

```
时间线：
0 ─── 1 ─── 5 ─── 10 ─── 17 ─── 26
│ P1 │ P2 │ P4 │  P1  │  P3  │
```

#### 等待时间计算

**P1的等待时间**：
- **到达时间**：0
- **完成时间**：17
- **执行时间**：8
- **等待时间**：17 - 0 - 8 = 9
- **或**：(10 - 1) = 9（从被抢占到重新执行）

**P2的等待时间**：
- **到达时间**：1
- **完成时间**：5
- **执行时间**：4
- **等待时间**：5 - 1 - 4 = 0
- **或**：(1 - 1) = 0（立即执行）

**P3的等待时间**：
- **到达时间**：2
- **完成时间**：26
- **执行时间**：9
- **等待时间**：26 - 2 - 9 = 15
- **或**：(17 - 2) = 15

**P4的等待时间**：
- **到达时间**：3
- **完成时间**：10
- **执行时间**：5
- **等待时间**：10 - 3 - 5 = 2
- **或**：(5 - 3) = 2

#### 平均等待时间
```
平均等待时间 = [(10-1) + (1-1) + (17-2) + (5-3)] / 4
            = [9 + 0 + 15 + 2] / 4
            = 26 / 4
            = 6.5
```

### 4. SRTF的特点

#### 优点
- **最小平均等待时间**
- **可以抢占长进程**

#### 缺点
- **需要知道剩余时间**
- **频繁抢占，上下文切换开销大**
- **可能导致长作业饥饿**

---

## 时间片轮转调度（Round Robin Scheduling）

### 1. 什么是RR？

#### 定义
- **RR（Round Robin）**：时间片轮转
- **每个进程获得一小单位CPU时间（时间量q，Time Quantum）**
- **通常10-100毫秒**

#### 工作原理
- **时间量用完后，进程被抢占**
- **添加到就绪队列的末尾**
- **下一个进程获得CPU**

### 2. RR的特点

#### 时间分配
- **如果有n个进程在就绪队列中，时间量是q**
- **每个进程一次最多获得q时间单位的CPU时间块**
- **每个进程获得1/n的CPU时间**

#### 等待时间保证
- **没有进程等待超过(n-1)q时间单位**
- **公平性保证**

#### 定时器中断
- **每个时间量定时器中断**
- **调度下一个进程**

### 3. RR性能

#### 时间量大的情况
- **q大 → 类似FIFO（FCFS）**
- **几乎不抢占**

#### 时间量小的情况
- **q小 → 真正的RR**
- **频繁切换**

#### 重要考虑
- **q必须相对于上下文切换足够大**
- **否则开销太高**
- **q通常10毫秒到100毫秒**
- **上下文切换 < 10微秒**

### 4. RR示例

#### 场景
- **进程突发时间**：
  - P1: 24
  - P2: 3
  - P3: 3
- **时间量q = 4**

#### 甘特图

```
时间线：
0 ── 4 ── 7 ── 10 ── 14 ── 18 ── 22 ── 26 ── 30
│ P1 │ P2 │ P3 │ P1 │ P1 │ P1 │ P1 │ P1 │ P1 │
```

#### 执行过程

**时间0-4**：P1执行4个单位（剩余20）
**时间4-7**：P2执行3个单位（完成）
**时间7-10**：P3执行3个单位（完成）
**时间10-14**：P1执行4个单位（剩余16）
**时间14-18**：P1执行4个单位（剩余12）
**时间18-22**：P1执行4个单位（剩余8）
**时间22-26**：P1执行4个单位（剩余4）
**时间26-30**：P1执行4个单位（完成）

### 5. 时间量和上下文切换时间

#### 关系
- **时间量应该远大于上下文切换时间**
- **否则大部分时间花在切换上**

#### 例子
- **时间量**：10毫秒
- **上下文切换**：10微秒
- **比例**：1000:1（合理）

### 6. 周转时间随时间量的变化

#### 规则
- **80%的CPU突发应该短于q**
- **这样大多数进程在一个时间量内完成**

#### 如果q太小
- **频繁切换**
- **周转时间增加**

#### 如果q太大
- **类似FCFS**
- **响应时间差**

### 7. RR的特点

#### 优点
- **公平**
- **响应时间好**
- **适合交互式系统**
- **没有饥饿**

#### 缺点
- **平均周转时间通常高于SJF**
- **但响应时间更好**
- **上下文切换开销**

---

## 优先级调度（Priority Scheduling）

### 1. 什么是优先级调度？

#### 定义
- **优先级号（整数）与每个进程关联**
- **CPU分配给优先级最高的进程**
- **最小整数 = 最高优先级**
- **或最大整数 = 最高优先级（取决于实现）**

### 2. 优先级调度的类型

#### ① 抢占式（Preemptive）
- **高优先级进程可以抢占低优先级进程**
- **更灵活**

#### ② 非抢占式（Nonpreemptive）
- **一旦分配CPU，进程保持直到完成**
- **更简单**

### 3. SJF是优先级调度

#### 关系
- **SJF是优先级调度**
- **优先级是预测的下一个CPU突发时间的倒数**
- **短突发 = 高优先级**

### 4. 优先级调度示例

#### 场景
- **进程突发时间和优先级**：
  - P1: 突发时间10，优先级3
  - P2: 突发时间1，优先级1（最高）
  - P3: 突发时间2，优先级4
  - P4: 突发时间1，优先级5
  - P5: 突发时间5，优先级2

#### 调度顺序
- **按优先级排序**：P2(1) → P5(2) → P1(3) → P3(4) → P4(5)

#### 甘特图

```
时间线：
0 ─── 1 ─── 3 ─── 13 ─── 15 ─── 16
│ P2 │ P5 │   P1   │ P3 │ P4 │
```

#### 等待时间计算

**P1的等待时间**：3
**P2的等待时间**：0
**P3的等待时间**：13
**P4的等待时间**：15
**P5的等待时间**：1

#### 平均等待时间
```
平均等待时间 = (3 + 0 + 13 + 15 + 1) / 5 = 6.4
```

### 5. 优先级调度的问题

#### 饥饿（Starvation）
- **低优先级进程可能永远不执行**
- **如果高优先级进程不断到达**

#### 解决方案：老化（Aging）
- **随着时间推移，增加进程的优先级**
- **防止无限期等待**

#### 老化示例
```
初始优先级：
P1: 1（高）
P2: 5（低）

经过一段时间后（老化）：
P1: 1（高）
P2: 4（提高）

再经过一段时间：
P1: 1（高）
P2: 3（进一步提高）

最终P2会获得执行机会
```

### 6. 优先级调度与时间片轮转结合

#### 方法
- **运行优先级最高的进程**
- **相同优先级的进程运行时间片轮转**

#### 示例

**场景**：
- P1: 突发时间4，优先级3
- P2: 突发时间5，优先级2
- P3: 突发时间8，优先级2
- P4: 突发时间7，优先级1（最高）
- P5: 突发时间3，优先级3
- **时间量 = 2**

#### 调度过程

**优先级1**：P4执行（时间量2，剩余5）
**优先级2**：P2和P3轮转
  - P2执行（时间量2，剩余3）
  - P3执行（时间量2，剩余6）
  - P2执行（时间量2，剩余1）
  - P3执行（时间量2，剩余4）
  - P2执行（1个单位，完成）
  - P3执行（时间量2，剩余2）
  - P3执行（时间量2，完成）
**优先级3**：P1和P5轮转
  - P1执行（时间量2，剩余2）
  - P5执行（时间量2，剩余1）
  - P1执行（时间量2，完成）
  - P5执行（1个单位，完成）
**回到优先级1**：P4执行（剩余5个单位，完成）

### 7. 优先级调度的特点

#### 优点
- **灵活**
- **可以反映进程重要性**
- **适合实时系统**

#### 缺点
- **可能导致饥饿**
- **需要老化机制**
- **优先级可能难以确定**

---

## 总结

### 关键概念回顾

1. **基本概念**：
   - CPU-I/O突发周期
   - CPU突发分布

2. **CPU调度器**：
   - 从就绪队列选择进程
   - 调度决策时机

3. **抢占式和非抢占式调度**：
   - 抢占式：可以中断进程
   - 非抢占式：进程主动放弃CPU

4. **调度准则**：
   - CPU利用率、吞吐量、周转时间、等待时间、响应时间

5. **调度算法**：
   - FCFS：简单但可能不公平
   - SJF：最优但难以预测
   - SRTF：抢占式SJF
   - RR：公平，适合交互式系统
   - 优先级：灵活但可能饥饿

### 学习要点

#### 必须理解的概念

1. **调度准则**：
   - 理解各种准则的含义
   - 知道如何计算

2. **各种调度算法**：
   - 理解每个算法的工作原理
   - 知道优缺点
   - 能够计算等待时间、周转时间等

3. **抢占式 vs 非抢占式**：
   - 理解区别
   - 知道何时使用

4. **时间量的选择**：
   - 理解时间量对性能的影响
   - 知道如何选择合适的时间量

### 实际应用

- **理解CPU调度**：操作系统如何分配CPU时间
- **选择调度算法**：根据系统类型选择合适算法
- **性能优化**：如何提高系统性能
- **公平性**：如何保证公平性
- **响应性**：如何提高响应时间

### 思考题

1. **FCFS和SJF的区别是什么？**
   - FCFS：按到达顺序
   - SJF：按突发时间长度

2. **为什么SJF是最优的？**
   - 对于给定进程集，给出最小平均等待时间

3. **RR时间量如何选择？**
   - 应该远大于上下文切换时间
   - 80%的CPU突发应该短于时间量

4. **优先级调度的问题是什么？如何解决？**
   - 问题：饥饿
   - 解决：老化机制

5. **抢占式和非抢占式调度的区别是什么？**
   - 抢占式：可以中断进程
   - 非抢占式：进程主动放弃CPU

---

*希望这个详细讲解能帮助你更好地理解CPU调度的基本概念和算法！如果有任何不清楚的地方，可以随时提问。*

