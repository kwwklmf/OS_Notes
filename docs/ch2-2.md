# 第2章：操作系统结构（第二部分）- 详细讲解

## 目录
1. [操作系统结构类型](#操作系统结构类型)
2. [分层方法](#分层方法)
3. [微内核](#微内核)
4. [模块化设计](#模块化设计)
5. [混合系统](#混合系统)
6. [macOS和iOS结构](#macos和ios结构)
7. [Android架构](#android架构)
8. [链接器和加载器](#链接器和加载器)
9. [构建和启动操作系统](#构建和启动操作系统)
10. [操作系统调试](#操作系统调试)
11. [应用程序的操作系统特定性](#应用程序的操作系统特定性)
12. [设计和实现](#设计和实现)

---

## 操作系统结构类型

### 1. 为什么需要不同的结构？

#### 问题
- **通用操作系统是非常大的程序**
- **需要组织代码**，使其：
  - 易于理解
  - 易于维护
  - 易于扩展
  - 性能良好

#### 解决方案
- **不同的结构方法**
- 每种方法有优缺点
- 现代操作系统通常使用**混合方法**

### 2. 主要结构类型

#### ① 简单结构（Simple Structure）
- **例子**：MS-DOS
- **特点**：没有明确的层次
- **问题**：难以维护和扩展

#### ② 分层结构（Layered）
- **例子**：早期操作系统
- **特点**：明确的层次
- **优势**：易于理解和维护

#### ③ 微内核（Microkernel）
- **例子**：Mach
- **特点**：最小内核，大部分功能在用户空间
- **优势**：可靠、安全、可移植

#### ④ 模块化（Modular）
- **例子**：Linux、Solaris
- **特点**：可加载的内核模块
- **优势**：灵活、可扩展

#### ⑤ 混合系统（Hybrid）
- **例子**：现代操作系统（Windows、macOS、Linux）
- **特点**：结合多种方法
- **优势**：平衡性能和灵活性

---

## 传统UNIX系统结构

### 1. 基本结构

#### 特点
- **超越简单结构**，但**不是完全分层**
- **两个可分离部分**：
  - **系统程序**
  - **内核**

#### 内核组成
- **系统调用接口以下**和**物理硬件以上**的所有内容
- **提供**：
  - 文件系统
  - CPU调度
  - 内存管理
  - 其他操作系统功能
- **问题**：一个级别有大量功能

### 2. 结构图

```
┌─────────────────────────────────┐
│        用户程序                  │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│      系统调用接口                │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│           内核                   │
│  ┌──────────┬──────────────┐   │
│  │文件系统   │ CPU调度       │   │
│  ├──────────┼──────────────┤   │
│  │内存管理   │ 其他功能      │   │
│  └──────────┴──────────────┘   │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│         硬件                     │
└─────────────────────────────────┘
```

### 3. 优缺点

#### 优点
- **简单**：结构清晰
- **性能好**：没有层次间的开销

#### 缺点
- **难以维护**：所有功能在一个内核中
- **难以扩展**：添加新功能需要修改内核
- **不够模块化**：功能耦合

---

## Linux系统结构

### 1. 基本特点

#### 设计
- **单体（Monolithic）加模块化设计**
- **结合了两种方法的优点**

#### 结构
- **核心内核**：基本功能
- **可加载内核模块（LKMs）**：动态加载功能

### 2. 模块化设计

#### 可加载内核模块（LKMs）
- **可以动态加载和卸载**
- **不需要重新编译内核**
- **例子**：
  - 设备驱动程序
  - 文件系统
  - 网络协议

#### 优势
- **灵活性**：可以添加新功能而不修改内核
- **可扩展性**：按需加载模块
- **维护性**：模块独立，易于维护

### 3. 例子

**加载模块**：
```bash
# 加载模块
sudo modprobe nvidia

# 查看已加载模块
lsmod

# 卸载模块
sudo modprobe -r nvidia
```

---

## 分层方法

### 1. 基本概念

#### 定义
- **操作系统分为多个层（级别）**
- **每一层构建在较低层之上**
- **底层（层0）是硬件**
- **最高层（层N）是用户界面**

#### 原则
- **模块化**：层被选择，使得每一层只使用较低层级的函数（操作）和服务

### 2. 分层结构图

```
┌─────────────────────────────────┐
│  层N：用户界面                   │
├─────────────────────────────────┤
│  层N-1：应用程序接口             │
├─────────────────────────────────┤
│  层N-2：系统服务                 │
├─────────────────────────────────┤
│  层N-3：设备管理                 │
├─────────────────────────────────┤
│  层N-4：内存管理                 │
├─────────────────────────────────┤
│  层N-5：CPU调度                 │
├─────────────────────────────────┤
│  层1：硬件抽象层                 │
├─────────────────────────────────┤
│  层0：硬件                       │
└─────────────────────────────────┘
```

### 3. 工作原理

#### 层间通信
- **每一层只能调用下一层的服务**
- **不能跨层调用**
- **例子**：
  - 层3可以调用层2
  - 层3不能直接调用层1

#### 例子：文件操作
```
用户程序（层N）
   ↓ 调用
文件系统接口（层N-1）
   ↓ 调用
设备管理（层N-2）
   ↓ 调用
硬件抽象（层1）
   ↓ 访问
硬件（层0）
```

### 4. 优缺点

#### 优点
- **易于理解**：层次清晰
- **易于维护**：修改一层不影响其他层
- **易于调试**：可以逐层调试
- **抽象**：每层隐藏下层细节

#### 缺点
- **性能开销**：层间调用有开销
- **灵活性差**：必须通过层间接口
- **可能过度分层**：导致不必要的复杂性

---

## 微内核

### 1. 基本概念

#### 定义
- **将尽可能多的功能从内核移到用户空间**
- **内核只保留最基本的功能**
- **用户空间模块通过消息传递通信**

#### 例子
- **Mach**：微内核的例子
- **Mac OS X内核（Darwin）**部分基于Mach

### 2. 微内核结构图

```
┌─────────────────────────────────┐
│        用户程序                  │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│      用户空间模块                │
│  ┌──────────┬──────────────┐   │
│  │文件系统   │ 设备驱动      │   │
│  ├──────────┼──────────────┤   │
│  │网络协议   │ 其他服务      │   │
│  └──────────┴──────────────┘   │
└─────────────────────────────────┘
              ↓（消息传递）
┌─────────────────────────────────┐
│         微内核                   │
│  ┌──────────┬──────────────┐   │
│  │进程管理   │ 内存管理      │   │
│  ├──────────┼──────────────┤   │
│  │消息传递   │ 基本调度      │   │
│  └──────────┴──────────────┘   │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│         硬件                     │
└─────────────────────────────────┘
```

### 3. 微内核的优势

#### ① 易于扩展
- **添加新功能**：只需添加用户空间模块
- **不需要修改内核**

#### ② 易于移植
- **内核小**：容易移植到新架构
- **用户空间模块**：可以针对不同平台编译

#### ③ 更可靠
- **更少的代码在内核模式运行**
- **内核崩溃的可能性更小**
- **用户空间模块崩溃不影响内核**

#### ④ 更安全
- **更小的内核**：攻击面更小
- **用户空间模块**：有更好的隔离

### 4. 微内核的缺点

#### 性能开销
- **用户空间到内核空间的通信开销**
- **消息传递**比直接函数调用慢
- **可能影响性能**

#### 例子
- **传统内核**：直接函数调用（快）
- **微内核**：消息传递（较慢）

### 5. 微内核 vs 单体内核

| 特性 | 单体内核 | 微内核 |
|------|---------|--------|
| **性能** | 快 | 较慢（消息传递开销） |
| **可靠性** | 较低（内核大） | 较高（内核小） |
| **可扩展性** | 困难 | 容易 |
| **可移植性** | 困难 | 容易 |
| **安全性** | 较低 | 较高 |

---

## 模块化设计

### 1. 基本概念

#### 定义
- **许多现代操作系统实现可加载内核模块（LKMs）**
- **使用面向对象方法**
- **每个核心组件是独立的**
- **通过已知接口相互通信**
- **根据需要在内核中加载**

#### 特点
- **整体上类似分层**，但**更灵活**
- **例子**：Linux、Solaris等

### 2. 模块化结构

```
┌─────────────────────────────────┐
│        用户程序                  │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│      系统调用接口                │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│         内核核心                 │
│  ┌──────────┬──────────────┐   │
│  │进程管理     │ 内存管理      │   │
│  └──────────┴──────────────┘   │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│      可加载内核模块              │
│  ┌──────────┬──────────────┐   │
│  │设备驱动   │ 文件系统      │   │
│  ├──────────┼──────────────┤   │
│  │网络协议   │ 其他模块      │   │
│  └──────────┴──────────────┘   │
└─────────────────────────────────┘
```

### 3. 模块化的优势

#### ① 灵活性
- **动态加载**：需要时加载
- **动态卸载**：不需要时卸载
- **不需要重新编译内核**

#### ② 可扩展性
- **添加新功能**：只需编写新模块
- **不影响内核核心**

#### ③ 维护性
- **模块独立**：易于维护
- **问题隔离**：模块问题不影响内核

#### ④ 性能
- **比微内核快**：模块在内核空间
- **比完全分层灵活**：可以按需加载

### 4. 例子：Linux模块

**查看已加载模块**：
```bash
lsmod
```

**加载模块**：
```bash
sudo modprobe nvidia
# 或
sudo insmod nvidia.ko
```

**卸载模块**：
```bash
sudo modprobe -r nvidia
# 或
sudo rmmod nvidia
```

---

## 混合系统

### 1. 基本概念

#### 定义
- **大多数现代操作系统不是单一纯模型**
- **混合系统结合多种方法**
- **解决性能、安全性、可用性需求**

### 2. 主要混合系统

#### ① Linux
- **内核在内核地址空间**：所以是单体的
- **加上模块化**：用于动态加载功能
- **特点**：单体内核 + 可加载模块

#### ② Windows
- **主要是单体**
- **加上微内核**：用于不同子系统个性
- **特点**：单体内核 + 微内核子系统

#### ③ Apple Mac OS X
- **混合、分层**
- **Aqua UI** + **Cocoa编程环境**
- **内核**：
  - **Mach微内核**
  - **BSD Unix部分**
  - **I/O工具包**
  - **动态可加载模块**（称为内核扩展）

### 3. 混合系统的优势

#### ① 性能
- **关键部分在内核空间**：性能好
- **非关键部分在用户空间**：安全

#### ② 灵活性
- **结合多种方法的优点**
- **根据需求选择合适的方法**

#### ③ 可维护性
- **模块化设计**：易于维护
- **清晰的接口**：易于扩展

---

## macOS和iOS结构

### 1. macOS结构

#### 层次结构
```
┌─────────────────────────────────┐
│      Aqua UI（用户界面）         │
├─────────────────────────────────┤
│      Cocoa编程环境               │
├─────────────────────────────────┤
│      应用程序框架                │
├─────────────────────────────────┤
│      核心服务                    │
├─────────────────────────────────┤
│      内核（Darwin）              │
│  ┌──────────┬──────────────┐   │
│  │Mach微内核 │ BSD Unix      │   │
│  ├──────────┼──────────────┤   │
│  │I/O工具包  │ 内核扩展      │   │
│  └──────────┴──────────────┘   │
└─────────────────────────────────┘
```

#### Darwin内核
- **Mach微内核**：提供基本服务
- **BSD Unix**：提供Unix兼容性
- **I/O工具包**：设备管理
- **内核扩展**：动态加载的模块

### 2. iOS结构

#### 基本特点
- **Apple移动操作系统**：用于iPhone、iPad
- **基于Mac OS X构建**，添加功能
- **不原生运行OS X应用程序**
- **运行在不同CPU架构**：ARM vs Intel

#### 层次结构
```
┌─────────────────────────────────┐
│      Cocoa Touch（UI框架）       │
├─────────────────────────────────┤
│      媒体服务层                  │
│  （图形、音频、视频）             │
├─────────────────────────────────┤
│      核心服务                    │
│  （云计算、数据库）               │
├─────────────────────────────────┤
│      核心操作系统                │
│  （基于Mac OS X内核）             │
└─────────────────────────────────┘
```

#### 开发
- **Cocoa Touch**：Objective-C API用于开发应用
- **媒体服务层**：图形、音频、视频
- **核心服务**：云计算、数据库
- **核心操作系统**：基于Mac OS X内核

### 3. iOS vs macOS

| 特性 | macOS | iOS |
|------|-------|-----|
| **CPU架构** | Intel/Apple Silicon | ARM |
| **应用程序** | OS X应用 | iOS应用 |
| **UI框架** | Cocoa | Cocoa Touch |
| **设备** | 桌面/笔记本 | 移动设备 |

---

## Android架构

### 1. 基本概念

#### 开发
- **由开放手机联盟（Open Handset Alliance）开发**（主要是Google）
- **开源**

#### 特点
- **类似iOS的堆栈**
- **基于Linux内核**但经过修改
- **提供**：
  - 进程管理
  - 内存管理
  - 设备驱动管理
- **添加**：电源管理

### 2. Android架构层次

```
┌─────────────────────────────────┐
│      应用程序                    │
│  （Java + Android API）          │
├─────────────────────────────────┤
│      应用程序框架                │
├─────────────────────────────────┤
│      运行时环境                  │
│  ┌──────────┬──────────────┐   │
│  │核心库     │ Dalvik VM     │   │
│  └──────────┴──────────────┘   │
├─────────────────────────────────┤
│      库                          │
│  （WebKit、SQLite、多媒体等）    │
├─────────────────────────────────┤
│      Linux内核（修改）            │
└─────────────────────────────────┘
```

### 3. 运行时环境

#### Dalvik虚拟机
- **核心库集**和**Dalvik虚拟机**
- **应用在Java中开发**加上Android API
- **Java类文件编译为Java字节码**
- **然后转换为可执行文件**，在Dalvik VM中运行

#### 库
- **WebKit**：Web浏览器框架
- **SQLite**：数据库
- **多媒体**：音频、视频处理
- **较小的libc**：C标准库

### 4. Android vs iOS

| 特性 | Android | iOS |
|------|---------|-----|
| **内核** | Linux（修改） | Darwin（Mach + BSD） |
| **开发语言** | Java | Objective-C/Swift |
| **虚拟机** | Dalvik/ART | 无（原生编译） |
| **开源** | 是 | 否 |
| **设备** | 多种制造商 | 仅Apple |

---

## 链接器和加载器

### 1. 编译和链接过程

#### 源代码到可执行文件

**步骤1：编译**
- **源代码编译为目标文件**
- **设计为加载到任何物理内存位置**
- **可重定位目标文件**

**步骤2：链接**
- **链接器组合这些文件**为单个二进制可执行文件
- **也引入库**

**步骤3：存储**
- **程序驻留在辅助存储**上作为二进制可执行文件

**步骤4：加载**
- **必须由加载器带入内存**才能执行
- **重定位**：为程序部分分配最终地址
- **调整代码和数据**以匹配这些地址

### 2. 静态链接 vs 动态链接

#### 静态链接
- **库链接到可执行文件中**
- **可执行文件包含所有需要的库**
- **优点**：独立，不需要外部库
- **缺点**：文件大，更新困难

#### 动态链接
- **现代通用系统不将库链接到可执行文件中**
- **动态链接库（DLL）**按需加载
- **共享**：所有使用相同版本库的程序共享
- **只加载一次**
- **优点**：文件小，易于更新
- **缺点**：需要库文件存在

#### 例子

**Windows**：
- **DLL**：动态链接库（.dll文件）
- **例子**：`kernel32.dll`, `user32.dll`

**Linux**：
- **共享库**：.so文件（Shared Object）
- **例子**：`libc.so`, `libpthread.so`

**macOS**：
- **动态库**：.dylib文件
- **例子**：`libSystem.dylib`

### 3. 文件格式

#### 标准格式
- **目标文件、可执行文件有标准格式**
- **操作系统知道如何加载和启动它们**

#### 常见格式

**Windows**：
- **PE格式**：Portable Executable
- **.exe, .dll文件**

**Linux/Unix**：
- **ELF格式**：Executable and Linkable Format
- **.o, .so, 可执行文件**

**macOS**：
- **Mach-O格式**：Mach Object
- **.o, .dylib, 可执行文件**

### 4. 链接器和加载器的角色

```
源代码（.c, .cpp）
   ↓ 编译
目标文件（.o）
   ↓ 链接（链接器）
可执行文件（.exe, 无扩展名）
   ↓ 加载（加载器）
内存中的程序
   ↓ 执行
运行的程序
```

#### 链接器（Linker）
- **组合目标文件**
- **解析符号引用**
- **链接库**
- **创建可执行文件**

#### 加载器（Loader）
- **将可执行文件加载到内存**
- **执行重定位**
- **设置初始状态**
- **启动程序执行**

---

## 构建和启动操作系统

### 1. 操作系统设计

#### 一般设计
- **操作系统设计为在具有各种外设的系统类上运行**
- **通常，操作系统已安装在购买的计算机上**
- **但可以构建和安装其他操作系统**

### 2. 从零构建操作系统

#### 步骤

**① 编写操作系统源代码**
- 编写操作系统源代码

**② 配置操作系统**
- **配置操作系统**用于将运行的系统
- **选择功能**、设备支持等

**③ 编译操作系统**
- 编译操作系统

**④ 安装操作系统**
- 安装操作系统

**⑤ 启动计算机**
- **启动计算机及其新操作系统**

### 3. 构建Linux

#### 步骤

**① 下载Linux源代码**
- 从 http://www.kernel.org 下载

**② 配置内核**
```bash
make menuconfig
```
- **图形界面**选择功能
- **生成配置文件**

**③ 编译内核**
```bash
make
```
- **产生vmlinuz**：内核镜像

**④ 编译内核模块**
```bash
make modules
```
- 编译可加载模块

**⑤ 安装内核模块**
```bash
make modules_install
```
- **将内核模块安装到vmlinuz**

**⑥ 安装新内核**
```bash
make install
```
- **在系统上安装新内核**

### 4. 系统启动（System Boot）

#### 启动过程

**① 电源初始化**
- **系统上电初始化时**，执行从固定内存位置开始
- **操作系统必须对硬件可用**，以便硬件可以启动它

**② 引导加载程序**
- **小段代码**：引导加载程序、BIOS
- **存储在ROM或EEPROM中**
- **定位内核**，将其加载到内存，并启动它

**③ 两步过程**
- **有时是两步过程**：
  - **ROM代码加载**固定位置的引导块
  - **引导块加载**磁盘上的引导加载程序

**④ 现代系统**
- **现代系统用UEFI替换BIOS**
- **UEFI**：统一可扩展固件接口（Unified Extensible Firmware Interface）

**⑤ GRUB**
- **常见引导加载程序**：GRUB
- **允许选择**：
  - 多个磁盘的内核
  - 多个版本
  - 内核选项

**⑥ 内核加载**
- **内核加载**，系统然后运行
- **引导加载程序**经常允许各种启动状态
- **例如**：单用户模式

### 5. 启动流程图

```
电源开启
   ↓
BIOS/UEFI执行
   ↓
硬件检测
   ↓
加载引导加载程序（GRUB等）
   ↓
选择内核
   ↓
加载内核到内存
   ↓
初始化内核
   ↓
启动系统服务
   ↓
显示登录界面
   ↓
系统就绪
```

---

## 操作系统调试

### 1. 什么是调试？

#### 定义
- **调试是查找和修复错误或bug**
- **也是性能调优**

#### Kernighan定律
> "调试比编写代码困难两倍。因此，如果你尽可能聪明地编写代码，根据定义，你不够聪明来调试它。"

**含义**：
- **编写清晰的代码**比编写"聪明"的代码更重要
- **易于调试的代码**比难以调试的"优化"代码更有价值

### 2. 调试信息

#### 日志文件
- **操作系统生成日志文件**，包含错误信息
- **例子**：
  - `/var/log/syslog`（Linux）
  - `/var/log/system.log`（macOS）
  - Event Viewer（Windows）

#### 核心转储（Core Dump）
- **应用程序失败**可以生成核心转储文件
- **捕获进程的内存**
- **用于分析崩溃原因**

#### 崩溃转储（Crash Dump）
- **操作系统失败**可以生成崩溃转储文件
- **包含内核内存**
- **用于分析系统崩溃**

### 3. 性能调优

#### 目的
- **通过消除瓶颈提高性能**
- **操作系统必须提供**计算和显示系统行为测量的方法

#### 工具

**① top程序（Linux/Unix）**
```bash
top
```
- **显示**：
  - CPU使用率
  - 内存使用
  - 运行进程
  - 系统负载

**② Windows任务管理器**
- **显示**：
  - CPU使用率
  - 内存使用
  - 运行进程
  - 网络活动

**③ 其他工具**
- **htop**：改进的top
- **Activity Monitor**（macOS）
- **Resource Monitor**（Windows）

### 4. 跟踪（Tracing）

#### 定义
- **收集特定事件的数据**
- **例如**：系统调用调用的步骤

#### 工具

**① strace（Linux）**
- **跟踪进程调用的系统调用**
- **例子**：
```bash
strace ls
# 显示ls命令调用的所有系统调用
```

**② gdb（GNU调试器）**
- **源代码级调试器**
- **可以**：
  - 设置断点
  - 单步执行
  - 检查变量
  - 查看调用栈

**③ perf（Linux性能工具集）**
- **Linux性能工具集合**
- **可以**：
  - 分析性能
  - 查找热点
  - 分析缓存行为

**④ tcpdump**
- **收集网络数据包**
- **用于网络调试**

### 5. BCC（BPF编译器集合）

#### 定义
- **丰富的工具包**，为Linux提供跟踪功能
- **调试用户级和内核代码之间的交互**
- **几乎不可能没有理解两者并检测其操作的工具集**

#### 功能
- **跟踪系统调用**
- **跟踪内核函数**
- **分析性能**
- **调试问题**

#### 例子

**disksnoop.py**
- **跟踪磁盘I/O活动**
- **显示**：
  - 哪些进程访问磁盘
  - 访问模式
  - 性能指标

**其他BCC工具**：
- **execsnoop**：跟踪进程执行
- **opensnoop**：跟踪文件打开
- **biolatency**：分析I/O延迟
- **许多其他工具**

### 6. DTrace

#### 定义
- **原始DTrace**（Solaris）
- **类似BCC的功能**
- **动态跟踪框架**

---

## 应用程序的操作系统特定性

### 1. 为什么应用程序是操作系统特定的？

#### 问题
- **在一个系统上编译的应用程序**通常不能在其他操作系统上执行
- **每个操作系统提供**：
  - 自己独特的系统调用
  - 自己的文件格式
  - 等等

#### 原因
- **不同的系统调用接口**
- **不同的文件格式**
- **不同的库**
- **不同的ABI**（应用程序二进制接口）

### 2. 跨平台应用程序

#### 方法

**① 解释语言**
- **用解释语言编写**，如Python、Ruby
- **解释器在多个操作系统上可用**
- **例子**：
  - Python程序可以在Windows、Linux、macOS上运行
  - 只要有Python解释器

**② 虚拟机语言**
- **用包含VM的语言编写**，运行应用程序（如Java）
- **例子**：
  - Java程序编译为字节码
  - 在JVM上运行
  - JVM针对不同平台

**③ 标准语言编译**
- **使用标准语言**（如C）
- **在每个操作系统上分别编译**以在每个上运行
- **例子**：
  - 用C编写程序
  - 在Windows上编译为.exe
  - 在Linux上编译为可执行文件
  - 在macOS上编译为Mach-O

### 3. 应用程序二进制接口（ABI）

#### 定义
- **ABI是架构等效的API**
- **定义二进制代码的不同组件如何接口**
- **用于给定操作系统、给定架构、CPU等**

#### 作用
- **定义**：
  - 函数调用约定
  - 数据结构布局
  - 寄存器使用
  - 系统调用接口

#### 例子
- **Windows x86-64 ABI**：Windows在x86-64上的ABI
- **Linux x86-64 ABI**：Linux在x86-64上的ABI
- **不同操作系统有不同的ABI**

---

## 设计和实现

### 1. 设计挑战

#### 基本问题
- **操作系统的设计和实现不是"可解决的"**
- **但一些方法已被证明成功**

#### 变化
- **不同操作系统的内部结构**可能差异很大
- **没有"正确"的方法**

### 2. 设计目标

#### 用户目标
- **操作系统应该**：
  - **方便使用**
  - **易于学习**
  - **可靠**
  - **安全**
  - **快速**

#### 系统目标
- **操作系统应该**：
  - **易于设计**
  - **易于实现**
  - **易于维护**
  - **灵活**
  - **可靠**
  - **无错误**
  - **高效**

#### 影响
- **受硬件选择影响**
- **受系统类型影响**
- **用户目标和系统目标**可能冲突

### 3. 策略和机制

#### 策略（Policy）
- **定义**：需要做什么
- **例子**：每100秒后中断

#### 机制（Mechanism）
- **定义**：如何做某事
- **例子**：定时器

#### 重要原则
- **将策略与机制分离**
- **这是非常重要的原则**
- **如果以后要更改策略决策，允许最大灵活性**

#### 例子
- **策略**：每100秒中断
- **机制**：定时器
- **改变策略**：改为每200秒中断
- **不需要改变机制**：只需改变策略参数

### 4. 实现

#### 语言选择

**早期操作系统**：
- **汇编语言**
- **非常快**，但难以维护

**系统编程语言**：
- **Algol, PL/1**
- **比汇编高级**

**现代操作系统**：
- **C, C++**
- **实际上通常是混合语言**

#### 语言混合

**最低级别**：
- **汇编语言**
- **关键性能部分**

**主体**：
- **C语言**
- **大部分操作系统代码**

**系统程序**：
- **C, C++**
- **脚本语言**：PERL, Python, shell脚本

#### 可移植性

**高级语言**：
- **更容易移植到其他硬件**
- **但较慢**

**模拟**：
- **可以允许操作系统在非本机硬件上运行**
- **通过模拟**

---

## 总结

### 关键概念回顾

1. **操作系统结构类型**：
   - 简单结构
   - 分层结构
   - 微内核
   - 模块化
   - 混合系统

2. **现代操作系统**：
   - Linux：单体 + 模块化
   - Windows：单体 + 微内核子系统
   - macOS：混合、分层

3. **移动操作系统**：
   - iOS：基于macOS
   - Android：基于Linux

4. **链接器和加载器**：
   - 静态链接 vs 动态链接
   - 文件格式

5. **构建和启动**：
   - 编译和配置
   - 引导过程

6. **调试**：
   - 日志文件
   - 性能调优
   - 跟踪工具

7. **应用程序特定性**：
   - 跨平台方法
   - ABI

8. **设计和实现**：
   - 设计目标
   - 策略和机制分离
   - 语言选择

### 学习要点

#### 必须理解的概念

1. **不同结构类型的优缺点**：
   - 何时使用哪种结构
   - 权衡性能、可靠性、可维护性

2. **现代操作系统的混合方法**：
   - 如何结合不同方法的优点

3. **链接和加载过程**：
   - 如何从源代码到可执行文件

4. **系统启动过程**：
   - 从电源到系统就绪

5. **调试方法**：
   - 如何查找和修复问题

### 实际应用

- **理解操作系统结构**：如何组织代码
- **理解构建过程**：如何编译和安装操作系统
- **理解启动过程**：系统如何启动
- **理解调试**：如何解决问题
- **理解跨平台开发**：如何编写可移植程序

### 思考题

1. **微内核和单体内核的区别是什么？**
   - 微内核：小内核，大部分功能在用户空间
   - 单体内核：大内核，所有功能在内核空间

2. **为什么现代操作系统使用混合方法？**
   - 平衡性能、可靠性、可维护性
   - 结合不同方法的优点

3. **静态链接和动态链接的区别是什么？**
   - 静态链接：库包含在可执行文件中
   - 动态链接：库按需加载

4. **系统启动的过程是什么？**
   - BIOS/UEFI → 引导加载程序 → 内核 → 系统服务

5. **策略和机制分离的重要性是什么？**
   - 允许灵活性
   - 易于修改策略而不改变机制

---

*希望这个详细讲解能帮助你更好地理解操作系统结构的更多概念！如果有任何不清楚的地方，可以随时提问。*

