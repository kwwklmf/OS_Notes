# 第10章：虚拟内存（第二部分）- 详细讲解

## 目录
1. [页替换的需求（Need For Page Replacement）](#页替换的需求)
2. [基本页替换（Basic Page Replacement）](#基本页替换)
3. [页替换算法评估（Page Replacement Algorithm Evaluation）](#页替换算法评估)
4. [FIFO算法（First-In-First-Out Algorithm）](#fifo算法)
5. [最优算法（Optimal Algorithm）](#最优算法)
6. [LRU算法（Least Recently Used Algorithm）](#lru算法)
7. [LRU近似算法（LRU Approximation Algorithms）](#lru近似算法)
8. [计数算法（Counting Algorithms）](#计数算法)
9. [页缓冲算法（Page-Buffering Algorithms）](#页缓冲算法)
10. [帧分配（Allocation of Frames）](#帧分配)
11. [全局vs局部分配（Global vs Local Allocation）](#全局vs局部分配)
12. [页回收（Reclaiming Pages）](#页回收)

---

## 页替换的需求（Need For Page Replacement）

### 1. 为什么需要页替换？

#### 问题场景
- **如果没有空闲帧怎么办？**
- **被进程页用完**
- **也按需从内核、I/O缓冲区等分配**
- **每个分配多少？**

#### 解决方案
- **页替换（Page Replacement）**：在内存中找到一些页，但实际上不在使用，将其分页出
- **算法 - 终止**
- **交换出（Swap Out）**
- **替换页（Replace the Page）**

### 2. 页替换的目标

#### 性能目标
- **性能 - 希望一个算法能够产生最少的页错误数**
- **同一页可能被多次带入内存**

#### 页替换的作用
- **通过修改页错误服务例程以包括页替换，防止内存过度分配**
- **使用修改（脏（Dirty））位减少页传输的开销**
- **只有修改的页才写入磁盘**
- **页替换完成逻辑内存和物理内存之间的分离**
- **可以在较小的物理内存上提供大的虚拟内存**

---

## 基本页替换（Basic Page Replacement）

### 1. 基本页替换的步骤

#### 步骤1：找到页的位置
- **在磁盘上找到所需页的位置**

#### 步骤2：找到空闲帧
- **如果有一个空闲帧，使用它**
- **如果没有空闲帧，使用页替换算法选择受害者帧（Victim Frame）**
- **如果脏，将受害者帧写入磁盘**

#### 步骤3：加载页
- **将所需页带入（新）空闲帧**
- **更新页表和帧表**

#### 步骤4：继续执行
- **通过重启导致陷阱的指令继续进程**

#### 注意
- **现在页错误可能传输2页 - 增加EAT**
- **如果受害者帧是脏的，需要先写回磁盘**

---

## 页替换算法评估（Page Replacement Algorithm Evaluation）

### 1. 帧分配算法vs页替换算法

#### 帧分配算法（Frame-Allocation Algorithm）
- **确定给每个进程多少帧**
- **确定替换哪些帧**

#### 页替换算法（Page-Replacement Algorithm）
- **希望第一次访问和重新访问时最低的页错误率**

### 2. 算法评估方法

#### 评估方式
- **通过在特定内存引用字符串（引用字符串（Reference String））上运行算法来评估算法**
- **计算该字符串上的页错误数**

#### 引用字符串
- **字符串只是页号，不是完整地址**
- **对同一页的重复访问不会导致页错误**

#### 结果依赖
- **结果取决于可用帧数**

### 3. 示例引用字符串

#### 标准引用字符串
- **在所有示例中，引用页号的引用字符串是**：
  **7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1**

### 4. 页错误数与帧数的关系

#### 一般规律
- **通常，可用帧数越多，页错误越少**
- **但某些算法可能违反这个规律**

---

## FIFO算法（First-In-First-Out Algorithm）

### 1. FIFO算法的基本概念

#### 工作原理
- **最简单的页替换算法**
- **替换最旧的页**
- **使用FIFO队列跟踪页的年龄**

#### 实现
- **只需使用FIFO队列**
- **新页添加到队列尾部**
- **替换队列头部的页**

### 2. FIFO算法示例

#### 场景
- **引用字符串**：7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1
- **3帧**（每个进程一次可以在内存中有3页）

#### 结果
- **15次页错误**

### 3. Belady异常（Belady's Anomaly）

#### 定义
- **Belady异常：增加更多帧可能导致更多页错误**

#### 例子
- **考虑引用字符串**：1,2,3,4,1,2,5,1,2,3,4,5
- **在某些情况下，增加帧数会导致更多页错误**

#### 原因
- **FIFO算法不考虑页的使用频率**
- **可能替换经常使用的页**

### 4. FIFO算法的优缺点

#### 优点
- **实现简单**
- **开销低**

#### 缺点
- **不考虑页的使用频率**
- **可能替换经常使用的页**
- **可能发生Belady异常**

---

## 最优算法（Optimal Algorithm）

### 1. 最优算法的基本概念

#### 工作原理
- **替换在最长一段时间内不会被使用的页**
- **在示例中，9是最优的**

#### 问题
- **你怎么知道这个？**
- **无法读取未来**

#### 用途
- **用于测量算法执行得如何**
- **作为基准（Benchmark）**

### 2. 最优算法的特点

#### 理论最优
- **理论上最优的算法**
- **产生最少的页错误**

#### 实际限制
- **无法在实际系统中实现**
- **需要知道未来的内存引用**

### 3. 最优算法的应用

#### 作为基准
- **用于评估其他算法**
- **如果算法接近最优，说明性能好**

#### 研究工具
- **用于研究页替换算法的理论性能**

---

## LRU算法（Least Recently Used Algorithm）

### 1. LRU算法的基本概念

#### 工作原理
- **使用过去的知识而不是未来**
- **替换在最多时间内未被使用的页**
- **将最后使用时间与每个页关联**

#### 性能
- **12次错误 - 比FIFO好但比OPT差**
- **通常良好的算法，经常使用**

### 2. LRU算法的实现

#### 问题
- **但如何实现？**

#### 方法1：计数器实现（Counter Implementation）

**工作原理**：
- **每个页项都有一个计数器**
- **每次通过此项引用页时，将时钟复制到计数器**
- **当需要更改页时，查看计数器以找到最小值**
- **需要搜索表**

**特点**：
- **需要搜索表**
- **每次引用都需要更新计数器**

#### 方法2：栈实现（Stack Implementation）

**工作原理**：
- **以双链接形式保持页号栈**：
  - **页被引用：将其移动到顶部**
  - **需要更改6个指针**
- **但每次更新更昂贵**
- **替换时无需搜索**

**特点**：
- **每个更新更昂贵**
- **但替换时无需搜索**

### 3. LRU和栈算法

#### 栈算法
- **LRU和OPT是栈算法的案例，没有Belady异常**
- **使用栈记录最近的页引用**

#### 栈操作
- **引用字符串**
- **引用前栈**
- **引用后栈**

#### 优势
- **不会发生Belady异常**
- **增加帧数总是减少或保持页错误数**

---

## LRU近似算法（LRU Approximation Algorithms）

### 1. 为什么需要近似算法？

#### LRU的问题
- **LRU需要特殊硬件，仍然很慢**
- **实际系统难以实现真正的LRU**

#### 解决方案
- **使用近似算法**
- **提供接近LRU的性能**
- **但实现更简单**

### 2. 引用位算法（Reference Bit Algorithm）

#### 基本概念
- **引用位（Reference Bit）**
- **与每个页关联一个位，最初 = 0**
- **当页被引用时，位设置为1**

#### 替换策略
- **替换任何引用位 = 0的页（如果存在）**
- **但我们不知道顺序**

#### 问题
- **不知道页被引用的顺序**
- **只能知道是否被引用**

### 3. 第二次机会算法（Second-Chance Algorithm）

#### 基本概念
- **通常FIFO，加上硬件提供的引用位**
- **时钟替换（Clock Replacement）**

#### 工作原理

**① 检查引用位**
- **如果要替换的页有**：
  - **引用位 = 0 -> 替换它**
  - **引用位 = 1 然后**：
    - **设置引用位0，将页留在内存中**
    - **替换下一页，遵循相同规则**

**② 时钟指针**
- **维护一个时钟指针**
- **指针在页帧上循环**
- **检查每个页的引用位**

#### 优势
- **给最近使用的页第二次机会**
- **比简单FIFO更好**
- **实现相对简单**

### 4. 增强的第二次机会算法（Enhanced Second-Chance Algorithm）

#### 基本概念
- **通过同时使用引用位和修改位（如果可用）来改进算法**
- **取有序对（引用，修改）**

#### 四个类别

**① (0, 0)**
- **既未最近使用也未修改**
- **最佳替换页**

**② (0, 1)**
- **未最近使用但已修改**
- **不是很好，必须在替换前写出**

**③ (1, 0)**
- **最近使用但干净**
- **可能很快会再次使用**

**④ (1, 1)**
- **最近使用且已修改**
- **可能很快会再次使用，需要在替换前写出**

#### 替换策略
- **当需要页替换时，使用时钟方案**
- **但使用四个类别**
- **替换最低非空类别中的页**
- **可能需要搜索循环队列几次**

#### 优势
- **考虑引用和修改状态**
- **减少不必要的磁盘写入**
- **更好的性能**

---

## 计数算法（Counting Algorithms）

### 1. 计数算法的基本概念

#### 工作原理
- **保持对每个页的引用数的计数器**
- **不常见**

### 2. 最少使用算法（Least Frequently Used, LFU）

#### 定义
- **最少使用（LFU）算法**
- **替换计数最小的页**

#### 特点
- **基于使用频率**
- **可能保留最近很少使用但之前经常使用的页**

### 3. 最常使用算法（Most Frequently Used, MFU）

#### 定义
- **最常使用（MFU）算法**
- **基于计数最小的页可能刚刚被带入且尚未使用的论点**

#### 特点
- **与直觉相反**
- **基于页刚刚被带入的假设**

---

## 页缓冲算法（Page-Buffering Algorithms）

### 1. 页缓冲算法的基本概念

#### 工作原理
- **保持一个空闲帧池，总是**
- **然后在需要时帧可用，不在错误时找到**
- **将页读入空闲帧并选择受害者驱逐并添加到空闲池**
- **方便时，驱逐受害者**

### 2. 修改页列表

#### 策略
- **可能，保持修改页列表**
- **当后备存储空闲时，将页写入那里并设置为非脏**
- **减少页错误时的延迟**

### 3. 保持帧内容

#### 策略
- **可能，保持空闲帧内容完整并注意其中的内容**
- **如果在重用之前再次引用，无需再次从磁盘加载内容**
- **如果选择了错误的受害者帧，通常有助于减少惩罚**

### 4. 页缓冲算法的优势

#### ① 减少延迟
- **页错误时立即有帧可用**
- **不需要等待选择受害者**

#### ② 减少I/O
- **如果页很快被重新引用，无需从磁盘加载**

#### ③ 提高性能
- **整体性能更好**

---

## 帧分配（Allocation of Frames）

### 1. 每个进程的最小帧数

#### 需求
- **每个进程需要最小数量的帧**
- **例如：IBM 370 - 6页来处理SS MOVE指令**：
  - **指令是6字节，可能跨越2页**
  - **2页来处理from**
  - **2页来处理to**

#### 最大值
- **当然最大值是系统中的总帧数**

### 2. 两种主要分配方案

#### ① 固定分配（Fixed Allocation）
- **每个进程分配固定数量的帧**
- **不随时间变化**

#### ② 优先级分配（Priority Allocation）
- **根据进程优先级分配帧**
- **高优先级进程获得更多帧**

#### 变化
- **许多变化**

### 3. 固定分配

#### ① 相等分配（Equal Allocation）
- **例如，如果有100帧（在分配OS的帧之后）和5个进程，给每个进程20帧**
- **保持一些作为空闲帧缓冲池**

#### ② 比例分配（Proportional Allocation）
- **根据进程大小分配**
- **动态，因为多道程序设计的程度、进程大小变化**

#### 比例分配公式
- **如果进程i的大小是Si，总大小是S**
- **进程i分配的帧数 = (Si / S) × 总帧数**

---

## 全局vs局部分配（Global vs Local Allocation）

### 1. 全局替换（Global Replacement）

#### 定义
- **全局替换 - 进程从所有帧集合中选择替换帧**
- **一个进程可以从另一个进程获取帧**

#### 特点

**① 执行时间变化**
- **但进程执行时间可能变化很大**

**② 更高吞吐量**
- **但更高吞吐量，所以更常见**

**③ 系统级优化**
- **系统级优化**
- **更灵活**

### 2. 局部替换（Local Replacement）

#### 定义
- **局部替换 - 每个进程仅从其自己的分配帧集合中选择**

#### 特点

**① 一致的性能**
- **每个进程的性能更一致**

**② 可能未充分利用内存**
- **但可能未充分利用内存**

**③ 进程级隔离**
- **进程级隔离**
- **一个进程不会影响另一个进程**

### 3. 实现全局页替换策略

#### 策略
- **所有内存请求都从空闲帧列表满足**
- **而不是等待列表降到零才开始选择页进行替换**
- **当列表降到某个阈值以下时，触发页替换**

#### 目标
- **此策略试图确保始终有足够的空闲内存来满足新请求**

---

## 页回收（Reclaiming Pages）

### 1. 页回收的基本概念

#### 定义
- **页回收（Reclaiming Pages）是从进程回收页的过程**
- **当系统需要更多空闲帧时**

### 2. 页回收策略

#### 主动回收
- **当空闲帧列表低于阈值时**
- **主动回收页**

#### 回收目标
- **选择不太可能很快使用的页**
- **基于LRU或其他算法**

### 3. 页回收示例

#### 场景
- **系统有多个进程**
- **空闲帧列表低于阈值**
- **需要回收一些页**

#### 过程
1. **识别可以回收的页**
2. **从进程回收页**
3. **将页添加到空闲帧列表**
4. **更新页表**

### 4. 页回收的优势

#### ① 保持空闲帧池
- **确保始终有足够的空闲帧**

#### ② 减少页错误延迟
- **页错误时立即有帧可用**

#### ③ 系统稳定性
- **防止内存耗尽**

---

## 应用程序和页替换（Applications and Page Replacement）

### 1. 操作系统猜测

#### 问题
- **所有这些算法都有操作系统猜测未来页访问**
- **操作系统不知道应用程序的访问模式**

### 2. 应用程序知识

#### 优势
- **某些应用程序有更好的知识**
- **例如：数据库**

### 3. 双重缓冲问题

#### 问题
- **内存密集型应用程序可能导致双重缓冲**
- **操作系统在内存中保留页的副本作为I/O缓冲区**
- **应用程序在内存中保留页用于自己的工作**

#### 解决方案
- **操作系统可以给予直接访问磁盘，避开应用程序**
- **原始磁盘模式（Raw Disk Mode）**
- **绕过缓冲、锁定等**

---

## 总结

### 关键概念回顾

1. **页替换的需求**：
   - 当没有空闲帧时
   - 防止内存过度分配
   - 完成逻辑和物理内存的分离

2. **基本页替换**：
   - 找到页的位置
   - 找到或创建空闲帧
   - 加载页
   - 重启指令

3. **FIFO算法**：
   - 最简单的算法
   - 可能发生Belady异常
   - 不考虑使用频率

4. **最优算法**：
   - 理论最优
   - 无法实际实现
   - 用作基准

5. **LRU算法**：
   - 使用过去的知识
   - 计数器或栈实现
   - 不会发生Belady异常

6. **LRU近似算法**：
   - 引用位算法
   - 第二次机会算法
   - 增强的第二次机会算法

7. **计数算法**：
   - LFU：最少使用
   - MFU：最常使用

8. **页缓冲算法**：
   - 保持空闲帧池
   - 减少延迟
   - 提高性能

9. **帧分配**：
   - 固定分配：相等或比例
   - 优先级分配
   - 最小和最大帧数

10. **全局vs局部分配**：
    - 全局：系统级，更灵活
    - 局部：进程级，更一致

11. **页回收**：
    - 主动回收页
    - 保持空闲帧池
    - 系统稳定性

12. **应用程序和页替换**：
    - 操作系统猜测
    - 应用程序可能有更好的知识
    - 双重缓冲问题

### 学习要点

#### 必须理解的概念

1. **页替换算法**：
   - 不同算法的优缺点
   - 如何选择算法

2. **Belady异常**：
   - 为什么发生
   - 哪些算法不会发生

3. **LRU实现**：
   - 计数器vs栈
   - 近似算法

4. **帧分配**：
   - 固定vs动态
   - 全局vs局部

5. **性能优化**：
   - 页缓冲
   - 页回收
   - 减少I/O

### 实际应用

- **理解现代内存管理**：页替换是现代操作系统的核心
- **理解性能优化**：如何选择最佳算法
- **理解系统设计**：全局vs局部分配的选择
- **理解应用程序需求**：应用程序特定的优化
- **理解系统稳定性**：页回收和内存管理

### 思考题

1. **为什么需要页替换？**
   - 当没有空闲帧时
   - 防止内存过度分配

2. **FIFO算法的问题是什么？**
   - 可能发生Belady异常
   - 不考虑使用频率

3. **为什么LRU是好的算法？**
   - 使用过去的知识
   - 不会发生Belady异常
   - 通常性能好

4. **全局vs局部分配的区别是什么？**
   - 全局：系统级，更灵活
   - 局部：进程级，更一致

5. **页缓冲算法如何提高性能？**
   - 页错误时立即有帧可用
   - 减少延迟
   - 如果页很快重新引用，无需从磁盘加载

---

*希望这个详细讲解能帮助你更好地理解虚拟内存的第二部分内容！如果有任何不清楚的地方，可以随时提问。*

