# 第9章：虚拟内存（第一部分）- 详细讲解

## 目录
1. [内存管理背景（Memory Management Background）](#内存管理背景)
2. [逻辑地址vs物理地址空间（Logical vs Physical Address Space）](#逻辑地址vs物理地址空间)
3. [内存管理单元（Memory-Management Unit, MMU）](#内存管理单元)
4. [动态加载和动态链接（Dynamic Loading and Linking）](#动态加载和动态链接)
5. [连续内存分配（Contiguous Allocation）](#连续内存分配)
6. [分页（Paging）](#分页)
7. [地址转换（Address Translation）](#地址转换)
8. [页表实现（Page Table Implementation）](#页表实现)
9. [转换后备缓冲器（Translation Look-Aside Buffer, TLB）](#转换后备缓冲器)
10. [有效访问时间（Effective Access Time）](#有效访问时间)
11. [内存保护（Memory Protection）](#内存保护)
12. [地址绑定（Address Binding）](#地址绑定)

---

## 内存管理背景（Memory Management Background）

### 1. 为什么需要内存管理？

#### 基本需求
- **程序必须从磁盘加载到内存中**
- **放在进程内才能运行**
- **主内存和寄存器是CPU可以直接访问的唯一存储**

#### 内存访问特点
- **寄存器访问**：在一个CPU时钟周期（或更少）内完成
- **主内存访问**：可能需要多个周期，导致停顿（Stall）
- **缓存（Cache）**：位于主内存和CPU寄存器之间

#### 内存保护需求
- **需要内存保护以确保正确操作**
- **防止进程访问不属于它的内存**

### 2. 内存管理单元的工作

#### 内存单元看到的
- **内存单元只看到流**：
  - **地址 + 读请求**
  - **地址 + 数据 + 写请求**

#### 保护的重要性
- **确保进程只能访问其地址空间中的地址**
- **防止非法访问**

---

## 逻辑地址vs物理地址空间（Logical vs Physical Address Space）

### 1. 基本概念

#### 核心思想
- **逻辑地址空间（Logical Address Space）绑定到独立的物理地址空间（Physical Address Space）的概念是正确内存管理的核心**

#### 地址类型

**① 逻辑地址（Logical Address）**
- **由CPU生成**
- **也称为虚拟地址（Virtual Address）**

**② 物理地址（Physical Address）**
- **内存单元看到的地址**
- **实际的内存位置**

### 2. 地址空间

#### 逻辑地址空间
- **程序生成的所有逻辑地址的集合**
- **程序看到的地址范围**

#### 物理地址空间
- **程序生成的所有物理地址的集合**
- **实际内存中的地址范围**

### 3. 地址绑定的时机

#### 编译时绑定（Compile-Time Binding）
- **逻辑地址和物理地址相同**
- **在编译时确定地址**
- **如果起始位置改变，必须重新编译**

#### 加载时绑定（Load-Time Binding）
- **逻辑地址和物理地址相同**
- **在加载时确定地址**
- **需要可重定位代码**

#### 执行时绑定（Execution-Time Binding）
- **逻辑地址和物理地址不同**
- **在执行时确定地址**
- **需要硬件支持（如基址和界限寄存器）**

### 4. 为什么需要逻辑地址？

#### 优势

**① 灵活性**
- **程序可以在任何物理位置运行**
- **不需要重新编译**

**② 保护**
- **进程无法直接访问物理内存**
- **通过MMU进行地址转换**

**③ 虚拟内存**
- **支持虚拟内存系统**
- **允许程序使用比物理内存更大的地址空间**

---

## 内存管理单元（Memory-Management Unit, MMU）

### 1. MMU的定义

#### 基本概念
- **硬件设备**
- **在运行时将虚拟地址映射到物理地址**
- **许多方法可能，在本章其余部分介绍**

### 2. 简单的MMU方案

#### 重定位寄存器方案（Relocation Register Scheme）
- **基址寄存器方案的泛化**
- **基址寄存器现在称为重定位寄存器（Relocation Register）**

#### 工作原理

**① 地址转换**
- **重定位寄存器中的值被添加到用户进程生成的每个地址**
- **在发送到内存时添加**

**② 用户程序视角**
- **用户程序处理逻辑地址**
- **永远看不到真实的物理地址**

**③ 执行时绑定**
- **当引用内存中的位置时发生执行时绑定**
- **逻辑地址绑定到物理地址**

### 3. MMU的工作流程

#### 步骤
1. **CPU生成逻辑地址**
2. **MMU接收逻辑地址**
3. **MMU将逻辑地址转换为物理地址**
4. **物理地址发送到内存单元**

#### 示例

假设：
- **逻辑地址**：1000
- **重定位寄存器值**：5000
- **物理地址**：1000 + 5000 = 6000

---

## 动态加载和动态链接（Dynamic Loading and Linking）

### 1. 动态加载（Dynamic Loading）

#### 基本概念
- **整个程序不需要都在内存中才能执行**
- **例程在调用之前不会被加载**
- **更好的内存空间利用率**
- **未使用的例程永远不会被加载**

#### 实现方式

**① 存储格式**
- **所有例程保存在磁盘上，以可重定位加载格式**

**② 适用场景**
- **当需要大量代码来处理不经常发生的情况时很有用**
- **例如错误处理例程**

**③ 操作系统支持**
- **操作系统不需要特殊支持**
- **通过程序设计实现**
- **操作系统可以通过提供库来帮助实现动态加载**

#### 动态加载的优势

**① 内存效率**
- **只加载需要的代码**
- **节省内存空间**

**② 灵活性**
- **可以根据需要加载不同的模块**

**③ 减少启动时间**
- **程序可以更快启动**
- **只加载必要的部分**

### 2. 动态链接（Dynamic Linking）

#### 基本概念

**① 静态链接（Static Linking）**
- **系统库和程序代码由加载器组合成二进制程序映像**
- **在加载时完成**

**② 动态链接（Dynamic Linking）**
- **链接推迟到执行时间**
- **在运行时完成**

#### 动态链接的工作原理

**① 存根（Stub）**
- **小段代码，存根**
- **用于定位适当的内存驻留库例程**

**② 替换过程**
- **存根用例程的地址替换自己**
- **执行例程**

**③ 操作系统检查**
- **操作系统检查例程是否在进程的内存地址中**
- **如果不在地址空间中，添加到地址空间**

#### 动态链接的优势

**① 共享库（Shared Libraries）**
- **系统也称为共享库**
- **多个进程可以共享同一个库**

**② 补丁系统库**
- **考虑对系统库打补丁的适用性**
- **可以更新库而不重新编译程序**

**③ 版本控制**
- **可能需要版本控制**
- **管理不同版本的库**

#### 动态链接vs静态链接

| 特性 | 静态链接 | 动态链接 |
|------|---------|---------|
| **链接时机** | 加载时 | 执行时 |
| **内存使用** | 每个程序都有库的副本 | 多个程序共享库 |
| **更新** | 需要重新编译 | 只需更新库 |
| **启动时间** | 较快 | 稍慢（需要链接） |
| **灵活性** | 较低 | 较高 |

---

## 连续内存分配（Contiguous Allocation）

### 1. 连续分配的基本概念

#### 需求
- **主内存必须支持操作系统和用户进程**
- **有限资源，必须高效分配**
- **连续分配是一种早期方法**

#### 内存分区

**① 两个分区**
- **主内存通常分为两个分区**：
  - **常驻操作系统**：通常保存在低内存中，带有中断向量
  - **用户进程**：然后保存在高内存中

**② 进程存储**
- **每个进程包含在内存的单个连续部分中**

### 2. 重定位和界限寄存器（Relocation and Limit Registers）

#### 目的
- **用于保护用户进程彼此不受影响**
- **防止更改操作系统代码和数据**

#### 寄存器功能

**① 基址寄存器（Base Register）**
- **包含最小物理地址的值**
- **用于地址转换**

**② 界限寄存器（Limit Register）**
- **包含逻辑地址的范围**
- **每个逻辑地址必须小于界限寄存器**

#### MMU映射
- **MMU动态映射逻辑地址**
- **可以允许诸如内核代码是瞬态的操作**
- **内核可以改变大小**

### 3. 硬件支持

#### 重定位和界限寄存器的硬件支持
- **硬件检查每个内存访问**
- **确保地址在基址和界限之间**

#### 工作流程
1. **CPU生成逻辑地址**
2. **MMU检查逻辑地址是否小于界限寄存器**
3. **如果有效，将逻辑地址添加到基址寄存器**
4. **生成物理地址**
5. **访问内存**

---

## 可变分区（Variable Partition）

### 1. 多分区分配

#### 基本概念
- **多分区分配**
- **多道程序设计的程度受分区数量限制**
- **可变分区大小以提高效率**（根据给定进程的需求调整大小）

### 2. 内存碎片（Holes）

#### 定义
- **孔（Hole）**：可用内存块
- **各种大小的孔分散在整个内存中**

#### 分配过程
- **当进程到达时，从足够大的孔中分配内存**
- **进程退出时释放其分区**
- **相邻的空闲分区合并**

### 3. 操作系统维护的信息

#### 需要跟踪的信息
- **a) 已分配的分区**
- **b) 空闲分区（孔）**

### 4. 动态存储分配问题

#### 问题
- **如何从空闲孔列表中满足大小为n的请求？**

#### 分配策略

**① 首次适应（First-Fit）**
- **分配第一个足够大的孔**
- **简单快速**
- **可能产生碎片**

**② 最佳适应（Best-Fit）**
- **分配最小的足够大的孔**
- **必须搜索整个列表，除非按大小排序**
- **产生最小的剩余孔**
- **可能产生许多小孔**

**③ 最差适应（Worst-Fit）**
- **分配最大的孔**
- **必须也搜索整个列表**
- **产生最大的剩余孔**
- **可能浪费内存**

#### 策略对比

| 策略 | 速度 | 存储利用率 | 碎片 |
|------|------|-----------|------|
| **首次适应** | 快 | 好 | 中等 |
| **最佳适应** | 慢 | 较好 | 多小孔 |
| **最差适应** | 慢 | 差 | 大孔 |

**结论**：**首次适应和最佳适应在速度和存储利用率方面优于最差适应**

---

## 碎片（Fragmentation）

### 1. 外部碎片（External Fragmentation）

#### 定义
- **总内存空间存在以满足请求**
- **但它不是连续的**
- **内存中有足够的总空间，但分散成小块**

#### 问题
- **即使有足够的空闲内存，也可能无法满足大进程的请求**
- **因为空闲内存不连续**

#### 首次适应分析
- **首次适应分析显示，给定N个已分配块，0.5N个块因碎片而丢失**
- **1/3可能无法使用 -> 50%规则**

### 2. 内部碎片（Internal Fragmentation）

#### 定义
- **分配的内存可能略大于请求的内存**
- **这种大小差异是分区内部的内存，但未被使用**

#### 原因
- **内存按固定大小块分配**
- **进程可能不需要整个块**

### 3. 减少外部碎片：压缩（Compaction）

#### 方法
- **通过压缩减少外部碎片**
- **打乱内存内容，将所有空闲内存放在一起，形成一个大块**

#### 要求
- **压缩只有在重定位是动态的，并且在执行时完成时才有可能**

#### 问题

**① I/O问题**
- **在涉及I/O时将作业锁定在内存中**
- **只对OS缓冲区进行I/O**

**② 后备存储碎片**
- **现在考虑后备存储也有相同的碎片问题**
- **磁盘也需要管理碎片**

---

## 分页（Paging）

### 1. 分页的基本概念

#### 核心思想
- **进程的物理地址空间可以是不连续的**
- **只要有可用的物理内存，就为进程分配物理内存**
- **避免外部碎片**
- **避免不同大小内存块的问题**

### 2. 分页的工作原理

#### ① 物理内存划分
- **将物理内存划分为固定大小的块，称为帧（Frames）**
- **大小是2的幂，在512字节和16 Mbytes之间**

#### ② 逻辑内存划分
- **将逻辑内存划分为相同大小的块，称为页（Pages）**
- **页大小 = 帧大小**

#### ③ 跟踪空闲帧
- **跟踪所有空闲帧**
- **维护空闲帧列表**

#### ④ 加载程序
- **要运行大小为N页的程序，需要找到N个空闲帧并加载程序**
- **设置页表以将逻辑地址转换为物理地址**

#### ⑤ 后备存储
- **后备存储同样分为页**
- **仍然有内部碎片**

### 3. 分页的优势

#### ① 避免外部碎片
- **没有外部碎片**
- **所有帧大小相同**

#### ② 灵活性
- **进程可以分布在非连续的内存中**
- **不需要连续的内存块**

#### ③ 简单管理
- **帧管理简单**
- **只需要跟踪空闲帧**

### 4. 分页的缺点

#### 内部碎片
- **仍然有内部碎片**
- **最后一页可能未完全使用**

#### 内部碎片计算

**例子**：
- **页大小 = 2,048字节**
- **进程大小 = 72,766字节**
- **35页 + 1,086字节**
- **内部碎片 = 2,048 - 1,086 = 962字节**

#### 碎片分析
- **最坏情况碎片 = 1帧 - 1字节**
- **平均碎片 = 1/2帧大小**
- **所以小帧大小是可取的**

#### 权衡
- **但每个页表项需要内存来跟踪**
- **页大小随时间增长**
- **Solaris支持两种页大小 - 8 KB和4 MB**

---

## 地址转换（Address Translation）

### 1. 地址转换方案

#### CPU生成的地址划分
- **CPU生成的地址分为**：
  - **页号（Page Number, p）**：用作页表的索引，页表包含物理内存中每页的基址
  - **页偏移（Page Offset, d）**：与基址组合以定义发送到内存单元的物理内存地址

#### 地址格式
- **对于给定的逻辑地址空间2^m和页大小2^n**：
  - **页号 = 地址的高位**
  - **页偏移 = 地址的低位**

### 2. 地址转换过程

#### 步骤
1. **CPU生成逻辑地址**
2. **提取页号p**
3. **使用p作为页表索引**
4. **从页表获取帧号f**
5. **将帧号f与页偏移d组合**
6. **生成物理地址**

#### 地址转换公式

```
物理地址 = (帧号 × 页大小) + 页偏移
```

或者：

```
物理地址 = (f × 2^n) + d
```

### 3. 分页示例

#### 场景
- **逻辑地址：n = 2和m = 4**
- **使用4字节的页大小和32字节的物理内存（8页）**

#### 地址格式
- **页号：2位（可以表示4页）**
- **页偏移：2位（可以表示4字节）**
- **总地址：4位**

#### 转换过程
假设逻辑地址是13（二进制：1101）：
- **页号p = 11（二进制）= 3**
- **页偏移d = 01（二进制）= 1**
- **从页表获取帧号f**
- **物理地址 = (f × 4) + 1**

---

## 页表实现（Page Table Implementation）

### 1. 页表存储

#### 基本实现
- **页表保存在主内存中**
- **页表基址寄存器（Page-Table Base Register, PTBR）指向页表**
- **页表长度寄存器（Page-Table Length Register, PTLR）指示页表的大小**

### 2. 两次内存访问问题

#### 问题
- **在这种方案中，每个数据/指令访问需要两次内存访问**：
  - **一次用于页表**
  - **一次用于数据/指令**

#### 性能影响
- **访问时间翻倍**
- **性能显著下降**

### 3. 解决方案：TLB

#### 转换后备缓冲器（Translation Look-Aside Buffer, TLB）
- **两次内存访问问题可以通过使用称为转换后备缓冲器（TLB）的特殊快速查找硬件缓存来解决**
- **也称为关联内存（Associative Memory）**

#### TLB的工作原理
- **TLB存储最近使用的页表项**
- **如果页号在TLB中，直接获取帧号**
- **如果不在，从页表加载到TLB**

---

## 转换后备缓冲器（Translation Look-Aside Buffer, TLB）

### 1. TLB的基本概念

#### 定义
- **特殊的高速硬件缓存**
- **存储最近使用的页表项**
- **也称为关联内存（Associative Memory）**

### 2. TLB的特性

#### ① 地址空间标识符（Address-Space Identifiers, ASIDs）
- **一些TLB在每个TLB项中存储地址空间标识符（ASIDs）**
- **唯一标识每个进程**
- **为该进程提供地址空间保护**
- **否则需要在每次上下文切换时刷新**

#### ② TLB大小
- **TLB通常很小（64到1,024项）**
- **因为硬件成本高**

#### ③ TLB未命中
- **在TLB未命中时，值被加载到TLB中以供下次更快访问**
- **需要从页表加载**

#### ④ 替换策略
- **必须考虑替换策略**
- **LRU、FIFO等**

#### ⑤ 固定项
- **某些项可以固定下来，用于永久快速访问**
- **例如内核代码**

### 3. TLB硬件

#### 关联内存
- **关联内存 - 并行搜索**
- **地址转换（p, d）**
- **如果p在关联寄存器中，获取帧号**
- **否则从内存中的页表获取帧号**

### 4. 带TLB的分页硬件

#### 工作流程
1. **CPU生成逻辑地址（p, d）**
2. **检查TLB中是否有p**
3. **如果命中（Hit），直接获取帧号f**
4. **如果未命中（Miss），从页表加载到TLB，然后获取帧号f**
5. **将帧号f与页偏移d组合**
6. **生成物理地址**

---

## 有效访问时间（Effective Access Time）

### 1. 命中率（Hit Ratio）

#### 定义
- **命中率 - 在TLB中找到页号的百分比**
- **80%的命中率意味着我们在TLB中找到所需页号的时间占80%**

### 2. 访问时间计算

#### 假设
- **假设访问内存需要10纳秒**

#### 两种情况

**① TLB命中**
- **如果我们在TLB中找到所需页**
- **映射内存访问需要10 ns**

**② TLB未命中**
- **否则我们需要两次内存访问**
- **所以是20 ns**（一次页表访问 + 一次数据访问）

### 3. 有效访问时间（EAT）计算

#### 公式

```
EAT = (命中率 × TLB命中时间) + ((1 - 命中率) × TLB未命中时间)
```

#### 例子1：80%命中率

```
EAT = 0.80 × 10 + 0.20 × 20
   = 8 + 4
   = 12 纳秒
```

**含义**：**访问时间有20%的减慢**

#### 例子2：99%命中率

```
EAT = 0.99 × 10 + 0.01 × 20
   = 9.9 + 0.2
   = 10.1 纳秒
```

**含义**：**访问时间只有1%的减慢**

### 4. 命中率的重要性

#### 观察
- **高命中率对性能至关重要**
- **99%命中率只导致1%的性能下降**
- **80%命中率导致20%的性能下降**

#### 优化建议
- **增加TLB大小可以提高命中率**
- **但硬件成本增加**
- **需要权衡**

---

## 内存保护（Memory Protection）

### 1. 保护需求

#### 基本需求
- **需要确保进程只能访问其地址空间中的地址**
- **防止非法访问**

### 2. 保护机制

#### 基址和界限寄存器
- **我们可以通过使用一对基址和界限寄存器来提供这种保护**
- **定义进程的逻辑地址空间**

#### 硬件地址保护
- **CPU必须检查在用户模式下生成的每个内存访问**
- **确保它在该用户的基址和界限之间**
- **加载基址和界限寄存器的指令是特权指令**

### 3. 保护的工作原理

#### 检查过程
1. **CPU生成逻辑地址**
2. **检查逻辑地址是否在界限内**
3. **如果有效，进行地址转换**
4. **如果无效，触发保护错误**

#### 特权指令
- **只有内核可以修改基址和界限寄存器**
- **用户程序无法修改**
- **确保保护机制有效**

---

## 地址绑定（Address Binding）

### 1. 程序在磁盘上

#### 初始状态
- **磁盘上的程序，准备加载到内存中执行，形成输入队列**
- **没有支持，必须加载到地址0000**
- **第一个用户进程的物理地址总是在0000是不方便的**
- **如何避免？**

### 2. 地址表示的不同方式

#### 程序生命周期的不同阶段
- **地址在程序生命周期的不同阶段以不同方式表示**

#### ① 源代码地址
- **源代码地址通常是符号的**
- **例如：变量名、函数名**

#### ② 编译代码地址
- **编译代码地址绑定到可重定位地址**
- **例如："距离此模块开头14字节"**

#### ③ 绝对地址
- **链接器或加载器将可重定位地址绑定到绝对地址**
- **例如：74014**

#### 绑定映射
- **每个绑定将一个地址空间映射到另一个地址空间**

### 3. 指令和数据到内存的绑定

#### 三个不同阶段的绑定

**① 编译时（Compile Time）**
- **如果内存位置事先已知，可以生成绝对代码**
- **如果起始位置改变，必须重新编译代码**
- **地址在编译时确定**

**② 加载时（Load Time）**
- **如果内存位置在编译时未知，必须生成可重定位代码**
- **地址在加载时确定**
- **需要可重定位代码**

**③ 执行时（Execution Time）**
- **如果进程在执行期间可以从一个内存段移动到另一个内存段，绑定延迟到运行时**
- **需要硬件支持地址映射**（例如，基址和界限寄存器）
- **地址在执行时确定**

### 4. 用户程序的多步处理

#### 处理步骤
1. **编译（Compilation）**：源代码 -> 目标代码
2. **链接（Linking）**：目标代码 -> 可执行文件
3. **加载（Loading）**：可执行文件 -> 内存
4. **执行（Execution）**：内存中的程序运行

#### 每个步骤的地址处理
- **编译时**：符号地址 -> 可重定位地址
- **链接时**：可重定位地址 -> 绝对地址（或保持可重定位）
- **加载时**：可重定位地址 -> 绝对地址
- **执行时**：逻辑地址 -> 物理地址（通过MMU）

---

## 总结

### 关键概念回顾

1. **逻辑地址vs物理地址**：
   - 逻辑地址由CPU生成
   - 物理地址是实际内存位置
   - 通过MMU进行转换

2. **内存管理单元（MMU）**：
   - 硬件设备
   - 在运行时将虚拟地址映射到物理地址
   - 使用重定位寄存器

3. **动态加载和动态链接**：
   - 动态加载：按需加载代码
   - 动态链接：运行时链接库
   - 提高内存效率

4. **连续内存分配**：
   - 基址和界限寄存器
   - 可变分区
   - 首次适应、最佳适应、最差适应

5. **碎片**：
   - 外部碎片：内存不连续
   - 内部碎片：分配的内存大于需要
   - 压缩可以减少外部碎片

6. **分页**：
   - 将内存分为固定大小的帧和页
   - 避免外部碎片
   - 仍然有内部碎片

7. **地址转换**：
   - 页号和页偏移
   - 通过页表转换
   - 物理地址 = (帧号 × 页大小) + 页偏移

8. **页表实现**：
   - 页表在主内存中
   - 每次访问需要两次内存访问
   - TLB可以解决这个问题

9. **转换后备缓冲器（TLB）**：
   - 硬件缓存
   - 存储最近使用的页表项
   - 显著提高性能

10. **有效访问时间**：
    - EAT = (命中率 × TLB命中时间) + ((1 - 命中率) × TLB未命中时间)
    - 高命中率对性能至关重要

11. **内存保护**：
    - 基址和界限寄存器
    - 硬件检查每个内存访问
    - 防止非法访问

12. **地址绑定**：
    - 编译时、加载时、执行时
    - 不同阶段使用不同的地址表示

### 学习要点

#### 必须理解的概念

1. **地址空间分离**：
   - 为什么需要逻辑地址和物理地址分离
   - 如何通过MMU进行转换

2. **分页机制**：
   - 分页如何工作
   - 地址转换过程
   - 页表的作用

3. **TLB的作用**：
   - 为什么需要TLB
   - TLB如何提高性能
   - 命中率对性能的影响

4. **内存分配策略**：
   - 首次适应、最佳适应、最差适应
   - 各自的优缺点

5. **碎片问题**：
   - 外部碎片和内部碎片的区别
   - 如何减少碎片

### 实际应用

- **理解现代内存管理**：分页是现代操作系统的基础
- **理解性能优化**：TLB对系统性能的重要性
- **理解内存保护**：如何防止进程访问非法内存
- **理解地址转换**：CPU如何访问内存
- **理解动态加载/链接**：现代程序如何工作

### 思考题

1. **为什么需要逻辑地址和物理地址分离？**
   - 提供灵活性、保护、虚拟内存支持

2. **分页如何避免外部碎片？**
   - 将内存分为固定大小的帧，所有帧大小相同

3. **TLB如何提高性能？**
   - 缓存页表项，减少内存访问次数

4. **首次适应和最佳适应的区别是什么？**
   - 首次适应：分配第一个足够大的孔
   - 最佳适应：分配最小的足够大的孔

5. **外部碎片和内部碎片的区别是什么？**
   - 外部碎片：内存不连续
   - 内部碎片：分配的内存大于需要

---

*希望这个详细讲解能帮助你更好地理解虚拟内存的第一部分内容！如果有任何不清楚的地方，可以随时提问。*

