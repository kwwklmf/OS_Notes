# 第5章：CPU调度（第二部分）- 详细讲解

## 目录
1. [多级队列调度（Multilevel Queue Scheduling）](#多级队列调度)
2. [多级反馈队列调度（Multilevel Feedback Queue Scheduling）](#多级反馈队列调度)
3. [多处理器调度（Multiple-Processor Scheduling）](#多处理器调度)
4. [实时CPU调度（Real-Time CPU Scheduling）](#实时cpu调度)
5. [线程调度（Thread Scheduling）](#线程调度)
6. [Pthread调度API](#pthread调度api)

---

## 多级队列调度（Multilevel Queue Scheduling）

### 1. 什么是多级队列？

#### 定义
- **就绪队列由多个队列组成**
- **不同队列可以有不同的调度算法**
- **根据进程类型或优先级分组**

#### 类比理解
想象多级队列是银行的不同服务窗口：
- **VIP窗口** = 高优先级队列
- **普通窗口** = 中优先级队列
- **简单业务窗口** = 低优先级队列
- **不同类型的客户去不同的窗口**

### 2. 多级队列调度器的参数

#### 定义参数

**① 队列数量（Number of Queues）**
- **有多少个队列**
- **每个队列代表不同的优先级或类型**

**② 每个队列的调度算法（Scheduling Algorithms for Each Queue）**
- **每个队列可以使用不同的调度算法**
- **例如**：高优先级队列用RR，低优先级队列用FCFS

**③ 确定进程进入哪个队列的方法（Method to Determine Queue）**
- **当进程需要服务时，如何决定它进入哪个队列**
- **根据进程类型、优先级等**

**④ 队列之间的调度（Scheduling Among the Queues）**
- **如何在不同队列之间调度**
- **通常：先调度高优先级队列**

### 3. 基于优先级的 multilevel queue

#### 基本结构
- **使用优先级调度，每个优先级有单独的队列**
- **调度最高优先级队列中的进程！**

#### 结构图

```
┌─────────────────────────────────┐
│  优先级1队列（最高）              │
│  ┌──────┬──────┬──────┐         │
│  │进程A │进程B │进程C │         │
│  └──────┴──────┴──────┘         │
├─────────────────────────────────┤
│  优先级2队列                     │
│  ┌──────┬──────┐                 │
│  │进程D │进程E │                 │
│  └──────┴──────┘                 │
├─────────────────────────────────┤
│  优先级3队列（最低）              │
│  ┌──────┐                         │
│  │进程F │                         │
│  └──────┘                         │
└─────────────────────────────────┘
```

#### 调度规则
- **总是先调度最高优先级队列**
- **只有高优先级队列为空时，才调度低优先级队列**

### 4. 基于进程类型的 multilevel queue

#### 结构
- **根据进程类型分组**
- **不同类型的进程有不同的调度需求**

#### 例子

```
┌─────────────────────────────────┐
│  系统进程队列                    │
│  （最高优先级，RR调度）            │
├─────────────────────────────────┤
│  交互式进程队列                  │
│  （高优先级，RR调度）              │
├─────────────────────────────────┤
│  批处理进程队列                  │
│  （低优先级，FCFS调度）            │
└─────────────────────────────────┘
```

#### 特点
- **系统进程**：需要快速响应
- **交互式进程**：需要良好的响应时间
- **批处理进程**：可以等待，注重吞吐量

---

## 多级反馈队列调度（Multilevel Feedback Queue Scheduling）

### 1. 什么是多级反馈队列？

#### 定义
- **进程可以在各种队列之间移动**
- **根据进程行为动态调整优先级**
- **结合了多级队列和优先级调整**

#### 关键特点
- **反馈机制**：根据进程执行情况调整队列
- **动态优先级**：进程可以升级或降级

### 2. 多级反馈队列调度器的参数

#### 定义参数

**① 队列数量（Number of Queues）**
- **有多少个队列**

**② 每个队列的调度算法（Scheduling Algorithms for Each Queue）**
- **每个队列使用的调度算法**

**③ 确定何时升级进程的方法（Method to Determine When to Upgrade）**
- **何时将进程移到更高优先级队列**

**④ 确定何时降级进程的方法（Method to Determine When to Demote）**
- **何时将进程移到更低优先级队列**

**⑤ 确定进程进入哪个队列的方法（Method to Determine Initial Queue）**
- **当进程需要服务时，它进入哪个队列**

### 3. 老化（Aging）的实现

#### 使用多级反馈队列
- **老化可以使用多级反馈队列实现**
- **长时间等待的进程可以升级到更高优先级队列**

### 4. 多级反馈队列示例

#### 三个队列

**① Q0**
- **RR调度，时间量8毫秒**
- **最高优先级**

**② Q1**
- **RR调度，时间量16毫秒**
- **中等优先级**

**③ Q2**
- **FCFS调度**
- **最低优先级**

#### 调度规则

**① 新进程进入Q0**
- **新进程进入队列Q0**
- **在Q0中以RR方式服务**

**② 获得CPU**
- **当它获得CPU时，进程获得8毫秒**

**③ 如果8毫秒内未完成**
- **进程被移到队列Q1**

**④ 在Q1中**
- **作业再次以RR方式服务**
- **获得额外的16毫秒**

**⑤ 如果仍未完成**
- **进程被抢占并移到队列Q2**

**⑥ 在Q2中**
- **以FCFS方式服务**
- **直到完成**

#### 流程图

```
新进程
  ↓
进入Q0（RR，时间量8ms）
  ↓
获得CPU，执行8ms
  ↓
完成？
  ├─ 是 → 结束
  └─ 否
      ↓
  移到Q1（RR，时间量16ms）
      ↓
  获得CPU，执行16ms
      ↓
  完成？
      ├─ 是 → 结束
      └─ 否
          ↓
      移到Q2（FCFS）
          ↓
      获得CPU，执行直到完成
          ↓
      结束
```

### 5. 多级反馈队列的优势

#### ① 适应性强
- **根据进程行为调整优先级**
- **短作业优先处理**
- **长作业不会阻塞短作业**

#### ② 防止饥饿
- **长时间等待的进程可以升级**
- **实现老化机制**

#### ③ 灵活性
- **可以适应不同类型的进程**
- **平衡响应时间和吞吐量**

### 6. 多级反馈队列的特点

#### 优点
- **适应性强**
- **防止饥饿**
- **适合混合工作负载**

#### 缺点
- **参数设置复杂**
- **需要仔细调整**
- **可能难以预测行为**

---

## 多处理器调度（Multiple-Processor Scheduling）

### 1. 多处理器调度的复杂性

#### 问题
- **当多个CPU可用时，CPU调度更复杂**
- **需要考虑负载平衡、缓存一致性等**

#### 多处理器架构类型

**① 多核CPU（Multicore CPUs）**
- **多个核心在同一物理芯片上**

**② 多线程核心（Multithreaded Cores）**
- **每个核心支持多个硬件线程**

**③ NUMA系统（NUMA Systems）**
- **非均匀内存访问系统**

**④ 异构多处理（Heterogeneous Multiprocessing）**
- **不同类型的处理器**

### 2. 对称多处理（Symmetric Multiprocessing, SMP）

#### 定义
- **每个处理器自主调度**
- **所有处理器平等**

#### 两种队列结构

**① 公共就绪队列（Common Ready Queue）**
- **所有线程在一个公共就绪队列中**
- **任何处理器可以从队列中选择线程**
- **需要同步机制**

**② 私有队列（Private Queue）**
- **每个处理器有自己的私有线程队列**
- **减少竞争**
- **但需要负载平衡**

### 3. 多核处理器（Multicore Processors）

#### 趋势
- **在同一物理芯片上放置多个处理器核心**
- **更快，功耗更低**

#### 特点
- **每个核心也有多个线程**
- **利用内存停顿（Memory Stall）**
- **在内存检索发生时，在另一个线程上取得进展**

### 4. 多线程多核系统（Multithreaded Multicore System）

#### 基本概念
- **每个核心有 > 1个硬件线程**
- **如果一个线程有内存停顿，切换到另一个线程**

#### 芯片多线程（Chip-Multithreading, CMT）

**定义**：
- **为每个核心分配多个硬件线程**
- **Intel称之为超线程（Hyperthreading）**

**例子**：
- **四核系统，每个核心2个硬件线程**
- **操作系统看到8个逻辑处理器**

#### 两级调度

**① 操作系统级**
- **操作系统决定哪个软件线程在逻辑CPU上运行**

**② 核心级**
- **每个核心决定哪个硬件线程在物理核心上运行**

### 5. 负载平衡（Load Balancing）

#### 问题
- **在SMP中，需要保持所有CPU负载以保持效率**
- **负载平衡尝试保持工作负载均匀分布**

#### 两种方法

**① 推送迁移（Push Migration）**
- **周期性任务检查每个处理器的负载**
- **如果发现，将任务从过载的CPU推送到其他CPU**
- **主动平衡**

**② 拉取迁移（Pull Migration）**
- **空闲处理器从忙碌处理器拉取等待任务**
- **被动平衡**

### 6. 处理器亲和性（Processor Affinity）

#### 问题
- **当线程在一个处理器上运行时**
- **该处理器的缓存内容存储该线程的内存访问**
- **我们称之为线程对处理器的亲和性（Processor Affinity）**

#### 负载平衡的影响
- **负载平衡可能影响处理器亲和性**
- **线程可能从一个处理器移动到另一个以平衡负载**
- **但线程失去了它在被移出的处理器缓存中的内容**

#### 两种亲和性

**① 软亲和性（Soft Affinity）**
- **操作系统尝试保持线程在同一处理器上运行**
- **但不保证**
- **允许负载平衡**

**② 硬亲和性（Hard Affinity）**
- **允许进程指定它可以运行的一组处理器**
- **保证线程只在指定处理器上运行**
- **不允许负载平衡移动**

### 7. NUMA和CPU调度

#### NUMA感知（NUMA-Aware）
- **如果操作系统是NUMA感知的**
- **它将分配内存靠近线程运行的CPU**
- **减少内存访问延迟**

#### 优势
- **提高性能**
- **减少内存访问时间**
- **更好地利用本地内存**

---

## 实时CPU调度（Real-Time CPU Scheduling）

### 1. 什么是实时系统？

#### 定义
- **实时系统有严格的时间约束**
- **任务必须在截止时间（Deadline）前完成**

#### 两种类型

**① 软实时系统（Soft Real-Time Systems）**
- **关键实时任务具有最高优先级**
- **但不保证任务何时被调度**
- **偶尔错过截止时间可以接受**

**② 硬实时系统（Hard Real-Time Systems）**
- **任务必须在其截止时间前得到服务**
- **错过截止时间是系统失败**
- **必须保证**

### 2. 实时调度的挑战

#### 明显的挑战
- **可以呈现明显的挑战**
- **需要可预测的调度**
- **需要保证截止时间**

### 3. 事件延迟（Event Latency）

#### 定义
- **从事件发生到事件被服务所经过的时间量**

#### 两种延迟类型

**① 中断延迟（Interrupt Latency）**
- **从中断到达 to 服务中断的例程开始的时间**
- **硬件中断到中断处理程序开始的时间**

**② 分发延迟（Dispatch Latency）**
- **调度器将当前进程从CPU上取下并切换到另一个进程的时间**
- **调度决策到进程开始执行的时间**

### 4. 中断延迟（Interrupt Latency）

#### 组成部分

```
中断发生
   ↓
硬件检测中断
   ↓
保存当前上下文
   ↓
跳转到中断处理程序
   ↓
中断处理程序开始执行
```

#### 影响因素
- **硬件响应时间**
- **中断屏蔽时间**
- **上下文保存时间**

### 5. 分发延迟（Dispatch Latency）

#### 冲突阶段（Conflict Phase）

**① 抢占在内核模式运行的任何进程**
- **如果进程在内核模式运行**
- **需要等待它返回用户模式**
- **或允许内核模式抢占**

**② 低优先级进程释放高优先级进程所需的资源**
- **高优先级进程可能需要低优先级进程持有的资源**
- **需要等待资源释放**

#### 减少分发延迟
- **允许内核模式抢占**
- **优先级继承（Priority Inheritance）**
- **快速上下文切换**

### 6. 基于优先级的调度（Priority-based Scheduling）

#### 实时调度的要求
- **调度器必须支持抢占式、基于优先级的调度**
- **但只保证软实时**
- **对于硬实时，还必须提供满足截止时间的能力**

### 7. 实时进程的特征

#### 周期性进程（Periodic Processes）
- **需要CPU以恒定间隔**
- **有处理时间t、截止时间d、周期p**
- **0 ≤ t ≤ d ≤ p**
- **周期性任务的速率是1/p**

#### 例子
- **视频播放**：每33ms需要一帧（30fps）
- **传感器采样**：每100ms采样一次
- **控制循环**：每10ms执行一次

### 8. 速率单调调度（Rate Monotonic Scheduling, RMS）

#### 定义
- **优先级根据其周期的倒数分配**
- **较短周期 = 较高优先级**
- **较长周期 = 较低优先级**

#### 公式
```
优先级 = 1 / 周期
```

#### 例子

**进程P1**：
- **周期p1 = 50ms**
- **优先级 = 1/50 = 0.02**

**进程P2**：
- **周期p2 = 100ms**
- **优先级 = 1/100 = 0.01**

**结果**：**P1的优先级高于P2**

#### 特点
- **固定优先级**
- **适合周期性任务**
- **可以保证可调度性（如果CPU利用率 < 69%）**

### 9. 速率单调调度的截止时间错过

#### 问题
- **在某些情况下，进程可能错过截止时间**
- **例如**：进程P2在时间80错过完成截止时间

#### 原因
- **CPU利用率过高**
- **任务周期冲突**
- **需要更复杂的调度算法**

### 10. 最早截止时间优先调度（Earliest Deadline First Scheduling, EDF）

#### 定义
- **优先级根据截止时间分配**
- **截止时间越早，优先级越高**
- **截止时间越晚，优先级越低**

#### 特点
- **动态优先级**
- **可以保证可调度性（如果CPU利用率 < 100%）**
- **比RMS更灵活**

#### 例子

**时间0**：
- **P1：截止时间50，优先级高**
- **P2：截止时间100，优先级低**
- **执行P1**

**时间25**：
- **P1完成**
- **P2：截止时间100，优先级高（唯一任务）**
- **执行P2**

**时间50**：
- **新P1到达：截止时间100**
- **P2：截止时间100**
- **相同截止时间，继续执行P2或切换**

#### 优势
- **可以100%利用CPU**
- **动态调整优先级**
- **适合硬实时系统**

---

## 线程调度（Thread Scheduling）

### 1. 用户级线程和内核级线程的区别

#### 关键区别
- **当支持线程时，调度线程，而不是进程**
- **线程是调度的单位**

### 2. 进程竞争范围（Process-Contention Scope, PCS）

#### 定义
- **多对一和多对多模型中**
- **线程库调度用户级线程在LWP上运行**
- **称为进程竞争范围（PCS）**
- **因为调度竞争在进程内**

#### 特点
- **通常通过程序员设置的优先级完成**
- **线程库管理调度**
- **操作系统不知道用户线程**

### 3. 系统竞争范围（System-Contention Scope, SCS）

#### 定义
- **内核线程被调度到可用CPU**
- **是系统竞争范围（SCS）**
- **系统中所有线程之间的竞争**

#### 特点
- **操作系统管理调度**
- **可以看到所有线程**
- **可以在不同CPU上运行**

### 4. PCS vs SCS

| 特性 | PCS | SCS |
|------|-----|-----|
| **调度范围** | 进程内 | 系统内 |
| **调度者** | 线程库 | 操作系统 |
| **可见性** | 操作系统不可见 | 操作系统可见 |
| **多核利用** | 困难 | 容易 |
| **开销** | 低 | 高 |

---

## Pthread调度API

### 1. Pthread调度API功能

#### 基本功能
- **允许在线程创建期间指定PCS或SCS**
- **控制线程的调度方式**

### 2. 调度范围类型

#### ① PTHREAD_SCOPE_PROCESS
- **使用PCS调度调度线程**
- **进程内调度**
- **线程库管理**

#### ② PTHREAD_SCOPE_SYSTEM
- **使用SCS调度调度线程**
- **系统级调度**
- **操作系统管理**

### 3. 系统限制

#### 操作系统限制
- **可能受操作系统限制**
- **Linux和macOS只允许PTHREAD_SCOPE_SYSTEM**
- **不支持PTHREAD_SCOPE_PROCESS**

### 4. Pthread调度API示例

#### 设置调度范围

```c
#include <pthread.h>
#include <stdio.h>

#define NUM_THREADS 5

int main(int argc, char *argv[]) {
    int i, scope;
    pthread_t tid[NUM_THREADS];
    pthread_attr_t attr;
    
    // 获取默认属性
    pthread_attr_init(&attr);
    
    // 首先查询当前范围
    if (pthread_attr_getscope(&attr, &scope) != 0)
        fprintf(stderr, "Unable to get scheduling scope\n");
    else {
        if (scope == PTHREAD_SCOPE_PROCESS)
            printf("PTHREAD_SCOPE_PROCESS\n");
        else if (scope == PTHREAD_SCOPE_SYSTEM)
            printf("PTHREAD_SCOPE_SYSTEM\n");
        else
            fprintf(stderr, "Illegal scope value.\n");
    }
    
    // 设置调度算法为PCS或SCS
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    
    // 创建线程
    for (i = 0; i < NUM_THREADS; i++)
        pthread_create(&tid[i], &attr, runner, NULL);
    
    // 等待每个线程
    for (i = 0; i < NUM_THREADS; i++)
        pthread_join(tid[i], NULL);
    
    return 0;
}

// 每个线程将在这个函数中开始控制
void *runner(void *param) {
    // 做一些工作...
    pthread_exit(0);
}
```

### 5. Pthread调度API的完整示例

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define NUM_THREADS 3

void *worker_thread(void *arg) {
    int thread_id = *(int *)arg;
    printf("Thread %d is running\n", thread_id);
    
    // 模拟工作
    sleep(2);
    
    printf("Thread %d completed\n", thread_id);
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    pthread_attr_t attr;
    int thread_ids[NUM_THREADS];
    int scope;
    
    // 初始化属性
    pthread_attr_init(&attr);
    
    // 获取当前调度范围
    if (pthread_attr_getscope(&attr, &scope) == 0) {
        if (scope == PTHREAD_SCOPE_PROCESS)
            printf("Current scope: PTHREAD_SCOPE_PROCESS\n");
        else if (scope == PTHREAD_SCOPE_SYSTEM)
            printf("Current scope: PTHREAD_SCOPE_SYSTEM\n");
    }
    
    // 设置调度范围为系统级
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    
    // 创建线程
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i;
        if (pthread_create(&threads[i], &attr, worker_thread, 
                          &thread_ids[i]) != 0) {
            fprintf(stderr, "Error creating thread %d\n", i);
            exit(1);
        }
    }
    
    // 等待所有线程完成
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    // 清理属性
    pthread_attr_destroy(&attr);
    
    printf("All threads completed\n");
    return 0;
}
```

---

## 总结

### 关键概念回顾

1. **多级队列调度（Multilevel Queue Scheduling）**：
   - 多个队列，不同调度算法
   - 基于优先级或进程类型

2. **多级反馈队列调度（Multilevel Feedback Queue Scheduling）**：
   - 进程可以在队列间移动
   - 动态调整优先级
   - 实现老化机制

3. **多处理器调度（Multiple-Processor Scheduling）**：
   - 负载平衡
   - 处理器亲和性
   - NUMA感知

4. **实时CPU调度（Real-Time CPU Scheduling）**：
   - 软实时和硬实时
   - 速率单调调度（RMS）
   - 最早截止时间优先（EDF）

5. **线程调度（Thread Scheduling）**：
   - 进程竞争范围（PCS）
   - 系统竞争范围（SCS）

6. **Pthread调度API**：
   - 设置调度范围
   - PCS和SCS的选择

### 学习要点

#### 必须理解的概念

1. **多级队列 vs 多级反馈队列**：
   - 多级队列：固定队列
   - 多级反馈队列：动态调整

2. **负载平衡**：
   - 推送迁移和拉取迁移
   - 处理器亲和性的权衡

3. **实时调度**：
   - RMS和EDF的区别
   - 如何保证截止时间

4. **线程调度范围**：
   - PCS和SCS的区别
   - 何时使用哪种

### 实际应用

- **理解现代调度算法**：多级反馈队列的实际应用
- **理解多核调度**：如何利用多核CPU
- **理解实时系统**：如何保证实时性
- **理解线程调度**：用户线程和内核线程的调度
- **理解性能优化**：负载平衡和处理器亲和性

### 思考题

1. **多级队列和多级反馈队列的区别是什么？**
   - 多级队列：进程固定在队列中
   - 多级反馈队列：进程可以在队列间移动

2. **为什么需要负载平衡？**
   - 保持所有CPU负载均匀
   - 提高系统效率

3. **软亲和性和硬亲和性的区别是什么？**
   - 软亲和性：尝试保持，但不保证
   - 硬亲和性：保证在指定处理器上

4. **RMS和EDF的区别是什么？**
   - RMS：固定优先级，基于周期
   - EDF：动态优先级，基于截止时间

5. **PCS和SCS的区别是什么？**
   - PCS：进程内调度
   - SCS：系统级调度

---

*希望这个详细讲解能帮助你更好地理解CPU调度的更多高级概念！如果有任何不清楚的地方，可以随时提问。*

